// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.time.InstantSource`
class InstantSource extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InstantSource> $type;

  @jni$_.internal
  InstantSource.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/InstantSource');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InstantSource$NullableType();
  static const type = $InstantSource$Type();
  static final _id_system = _class.staticMethodId(
    r'system',
    r'()Ljava/time/InstantSource;',
  );

  static final _system =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.InstantSource system()`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? system() {
    return _system(
      _class.reference.pointer,
      _id_system as jni$_.JMethodIDPtr,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_tick = _class.staticMethodId(
    r'tick',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _tick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource tick(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? tick(InstantSource? instantSource, Duration? duration) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _tick(
      _class.reference.pointer,
      _id_tick as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_fixed = _class.staticMethodId(
    r'fixed',
    r'(Ljava/time/Instant;)Ljava/time/InstantSource;',
  );

  static final _fixed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource fixed(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? fixed(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _fixed(
      _class.reference.pointer,
      _id_fixed as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_offset = _class.staticMethodId(
    r'offset',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _offset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource offset(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? offset(
    InstantSource? instantSource,
    Duration? duration,
  ) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _offset(
      _class.reference.pointer,
      _id_offset as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_instant = _class.instanceMethodId(
    r'instant',
    r'()Ljava/time/Instant;',
  );

  static final _instant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.Instant instant()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? instant() {
    return _instant(
      reference.pointer,
      _id_instant as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_millis = _class.instanceMethodId(r'millis', r'()J');

  static final _millis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long millis()`
  int millis() {
    return _millis(reference.pointer, _id_millis as jni$_.JMethodIDPtr).long;
  }

  static final _id_withZone = _class.instanceMethodId(
    r'withZone',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _withZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Clock withZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  Clock? withZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZone(
      reference.pointer,
      _id_withZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $InstantSource> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'system()Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.system();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'tick(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.tick(
          $a![0]?.as(const $InstantSource$Type(), releaseOriginal: true),
          $a![1]?.as(const $Duration$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'fixed(Ljava/time/Instant;)Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.fixed(
          $a![0]?.as(const $Instant$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'offset(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.offset(
          $a![0]?.as(const $InstantSource$Type(), releaseOriginal: true),
          $a![1]?.as(const $Duration$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'instant()Ljava/time/Instant;') {
        final $r = _$impls[$p]!.instant();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'millis()J') {
        final $r = _$impls[$p]!.millis();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'withZone(Ljava/time/ZoneId;)Ljava/time/Clock;') {
        final $r = _$impls[$p]!.withZone(
          $a![0]?.as(const $ZoneId$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $InstantSource $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.time.InstantSource', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory InstantSource.implement($InstantSource $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return InstantSource.fromReference($i.implementReference());
  }
}

abstract base mixin class $InstantSource {
  factory $InstantSource({
    required InstantSource? Function() system,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    tick,
    required InstantSource? Function(Instant? instant) fixed,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    offset,
    required Instant? Function() instant,
    required int Function() millis,
    required Clock? Function(ZoneId? zoneId) withZone,
  }) = _$InstantSource;

  InstantSource? system();
  InstantSource? tick(InstantSource? instantSource, Duration? duration);
  InstantSource? fixed(Instant? instant);
  InstantSource? offset(InstantSource? instantSource, Duration? duration);
  Instant? instant();
  int millis();
  Clock? withZone(ZoneId? zoneId);
}

final class _$InstantSource with $InstantSource {
  _$InstantSource({
    required InstantSource? Function() system,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    tick,
    required InstantSource? Function(Instant? instant) fixed,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    offset,
    required Instant? Function() instant,
    required int Function() millis,
    required Clock? Function(ZoneId? zoneId) withZone,
  }) : _system = system,
       _tick = tick,
       _fixed = fixed,
       _offset = offset,
       _instant = instant,
       _millis = millis,
       _withZone = withZone;

  final InstantSource? Function() _system;
  final InstantSource? Function(
    InstantSource? instantSource,
    Duration? duration,
  )
  _tick;
  final InstantSource? Function(Instant? instant) _fixed;
  final InstantSource? Function(
    InstantSource? instantSource,
    Duration? duration,
  )
  _offset;
  final Instant? Function() _instant;
  final int Function() _millis;
  final Clock? Function(ZoneId? zoneId) _withZone;

  InstantSource? system() {
    return _system();
  }

  InstantSource? tick(InstantSource? instantSource, Duration? duration) {
    return _tick(instantSource, duration);
  }

  InstantSource? fixed(Instant? instant) {
    return _fixed(instant);
  }

  InstantSource? offset(InstantSource? instantSource, Duration? duration) {
    return _offset(instantSource, duration);
  }

  Instant? instant() {
    return _instant();
  }

  int millis() {
    return _millis();
  }

  Clock? withZone(ZoneId? zoneId) {
    return _withZone(zoneId);
  }
}

final class $InstantSource$NullableType extends jni$_.JObjType<InstantSource?> {
  @jni$_.internal
  const $InstantSource$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/InstantSource;';

  @jni$_.internal
  @core$_.override
  InstantSource? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InstantSource.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstantSource?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstantSource$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstantSource$NullableType) &&
        other is $InstantSource$NullableType;
  }
}

final class $InstantSource$Type extends jni$_.JObjType<InstantSource> {
  @jni$_.internal
  const $InstantSource$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/InstantSource;';

  @jni$_.internal
  @core$_.override
  InstantSource fromReference(jni$_.JReference reference) =>
      InstantSource.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstantSource?> get nullableType =>
      const $InstantSource$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstantSource$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstantSource$Type) &&
        other is $InstantSource$Type;
  }
}

/// from: `java.time.ZonedDateTime`
class ZonedDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZonedDateTime> $type;

  @jni$_.internal
  ZonedDateTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZonedDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZonedDateTime$NullableType();
  static const type = $ZonedDateTime$Type();
  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.ZonedDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/ZonedDateTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDate localDate, java.time.LocalTime localTime, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of(
    LocalDate? localDate,
    LocalTime? localTime,
    ZoneId? zoneId,
  ) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localTime.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDateTime localDateTime, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of$1(LocalDateTime? localDateTime, ZoneId? zoneId) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(IIIIIIILjava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(int i, int i1, int i2, int i3, int i4, int i5, int i6, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of$2(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    ZoneId? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofLocal = _class.staticMethodId(
    r'ofLocal',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;Ljava/time/ZoneOffset;)Ljava/time/ZonedDateTime;',
  );

  static final _ofLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofLocal(java.time.LocalDateTime localDateTime, java.time.ZoneId zoneId, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofLocal(
    LocalDateTime? localDateTime,
    ZoneId? zoneId,
    ZoneOffset? zoneOffset,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _ofLocal(
      _class.reference.pointer,
      _id_ofLocal as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneId.pointer,
      _$zoneOffset.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant$1 = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofInstant$1(
    LocalDateTime? localDateTime,
    ZoneOffset? zoneOffset,
    ZoneId? zoneId,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant$1(
      _class.reference.pointer,
      _id_ofInstant$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneOffset.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofStrict = _class.staticMethodId(
    r'ofStrict',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofStrict =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofStrict(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofStrict(
    LocalDateTime? localDateTime,
    ZoneOffset? zoneOffset,
    ZoneId? zoneId,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofStrict(
      _class.reference.pointer,
      _id_ofStrict as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneOffset.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZonedDateTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/ZonedDateTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/ZonedDateTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneOffset? getOffset() {
    return _getOffset(
      reference.pointer,
      _id_getOffset as jni$_.JMethodIDPtr,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_withEarlierOffsetAtOverlap = _class.instanceMethodId(
    r'withEarlierOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withEarlierOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime withEarlierOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withEarlierOffsetAtOverlap() {
    return _withEarlierOffsetAtOverlap(
      reference.pointer,
      _id_withEarlierOffsetAtOverlap as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withLaterOffsetAtOverlap = _class.instanceMethodId(
    r'withLaterOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withLaterOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime withLaterOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withLaterOffsetAtOverlap() {
    return _withLaterOffsetAtOverlap(
      reference.pointer,
      _id_withLaterOffsetAtOverlap as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_getZone = _class.instanceMethodId(
    r'getZone',
    r'()Ljava/time/ZoneId;',
  );

  static final _getZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneId? getZone() {
    return _getZone(
      reference.pointer,
      _id_getZone as jni$_.JMethodIDPtr,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_withZoneSameLocal = _class.instanceMethodId(
    r'withZoneSameLocal',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime withZoneSameLocal(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withZoneSameLocal(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZoneSameLocal(
      reference.pointer,
      _id_withZoneSameLocal as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withZoneSameInstant = _class.instanceMethodId(
    r'withZoneSameInstant',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime withZoneSameInstant(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withZoneSameInstant(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZoneSameInstant(
      reference.pointer,
      _id_withZoneSameInstant as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withFixedOffsetZone = _class.instanceMethodId(
    r'withFixedOffsetZone',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withFixedOffsetZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime withFixedOffsetZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withFixedOffsetZone() {
    return _withFixedOffsetZone(
      reference.pointer,
      _id_withFixedOffsetZone as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toLocalDateTime = _class.instanceMethodId(
    r'toLocalDateTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _toLocalDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDateTime toLocalDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? toLocalDateTime() {
    return _toLocalDateTime(
      reference.pointer,
      _id_toLocalDateTime as jni$_.JMethodIDPtr,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? toLocalDate() {
    return _toLocalDate(
      reference.pointer,
      _id_toLocalDate as jni$_.JMethodIDPtr,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() {
    return _getYear(
      reference.pointer,
      _id_getYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() {
    return _getMonthValue(
      reference.pointer,
      _id_getMonthValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() {
    return _getMonth(
      reference.pointer,
      _id_getMonth as jni$_.JMethodIDPtr,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() {
    return _getDayOfMonth(
      reference.pointer,
      _id_getDayOfMonth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() {
    return _getDayOfYear(
      reference.pointer,
      _id_getDayOfYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() {
    return _getDayOfWeek(
      reference.pointer,
      _id_getDayOfWeek as jni$_.JMethodIDPtr,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() {
    return _toLocalTime(
      reference.pointer,
      _id_toLocalTime as jni$_.JMethodIDPtr,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() {
    return _getHour(
      reference.pointer,
      _id_getHour as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() {
    return _getMinute(
      reference.pointer,
      _id_getMinute as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() {
    return _getSecond(
      reference.pointer,
      _id_getSecond as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/ZonedDateTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/ZonedDateTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withYear(int i) {
    return _withYear(
      reference.pointer,
      _id_withYear as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withMonth(int i) {
    return _withMonth(
      reference.pointer,
      _id_withMonth as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withDayOfMonth(int i) {
    return _withDayOfMonth(
      reference.pointer,
      _id_withDayOfMonth as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withDayOfYear(int i) {
    return _withDayOfYear(
      reference.pointer,
      _id_withDayOfYear as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withHour(int i) {
    return _withHour(
      reference.pointer,
      _id_withHour as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withMinute(int i) {
    return _withMinute(
      reference.pointer,
      _id_withMinute as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withSecond(int i) {
    return _withSecond(
      reference.pointer,
      _id_withSecond as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withNano(int i) {
    return _withNano(
      reference.pointer,
      _id_withNano as jni$_.JMethodIDPtr,
      i,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusYears(int j) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusMonths(int j) {
    return _plusMonths(
      reference.pointer,
      _id_plusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusWeeks(int j) {
    return _plusWeeks(
      reference.pointer,
      _id_plusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusDays(int j) {
    return _plusDays(
      reference.pointer,
      _id_plusDays as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusHours(int j) {
    return _plusHours(
      reference.pointer,
      _id_plusHours as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusMinutes(int j) {
    return _plusMinutes(
      reference.pointer,
      _id_plusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusYears(int j) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusMonths(int j) {
    return _minusMonths(
      reference.pointer,
      _id_minusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusWeeks(int j) {
    return _minusWeeks(
      reference.pointer,
      _id_minusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusDays(int j) {
    return _minusDays(
      reference.pointer,
      _id_minusDays as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusHours(int j) {
    return _minusHours(
      reference.pointer,
      _id_minusHours as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusMinutes(int j) {
    return _minusMinutes(
      reference.pointer,
      _id_minusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toOffsetDateTime = _class.instanceMethodId(
    r'toOffsetDateTime',
    r'()Ljava/time/OffsetDateTime;',
  );

  static final _toOffsetDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.OffsetDateTime toOffsetDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? toOffsetDateTime() {
    return _toOffsetDateTime(
      reference.pointer,
      _id_toOffsetDateTime as jni$_.JMethodIDPtr,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZonedDateTime$NullableType extends jni$_.JObjType<ZonedDateTime?> {
  @jni$_.internal
  const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZonedDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$NullableType) &&
        other is $ZonedDateTime$NullableType;
  }
}

final class $ZonedDateTime$Type extends jni$_.JObjType<ZonedDateTime> {
  @jni$_.internal
  const $ZonedDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime fromReference(jni$_.JReference reference) =>
      ZonedDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType =>
      const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$Type) &&
        other is $ZonedDateTime$Type;
  }
}

/// from: `java.time.LocalDateTime`
class LocalDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LocalDateTime> $type;

  @jni$_.internal
  LocalDateTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/LocalDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LocalDateTime$NullableType();
  static const type = $LocalDateTime$Type();
  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/LocalDateTime;',
  );

  /// from: `static public final java.time.LocalDateTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? get MIN =>
      _id_MIN.get(_class, const $LocalDateTime$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/LocalDateTime;',
  );

  /// from: `static public final java.time.LocalDateTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? get MAX =>
      _id_MAX.get(_class, const $LocalDateTime$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.LocalDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/LocalDateTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/LocalDateTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;III)Ljava/time/LocalDateTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, java.time.Month month, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of(int i, Month? month, int i1, int i2, int i3) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
      i2,
      i3,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;IIII)Ljava/time/LocalDateTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, java.time.Month month, int i1, int i2, int i3, int i4)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$1(
    int i,
    Month? month,
    int i1,
    int i2,
    int i3,
    int i4,
  ) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
      i2,
      i3,
      i4,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;IIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, java.time.Month month, int i1, int i2, int i3, int i4, int i5)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$2(
    int i,
    Month? month,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
      i2,
      i3,
      i4,
      i5,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$3 = _class.staticMethodId(
    r'of',
    r'(IIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, int i1, int i2, int i3, int i4)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$3(int i, int i1, int i2, int i3, int i4) {
    return _of$3(
      _class.reference.pointer,
      _id_of$3 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      i4,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$4 = _class.staticMethodId(
    r'of',
    r'(IIIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, int i1, int i2, int i3, int i4, int i5)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$4(int i, int i1, int i2, int i3, int i4, int i5) {
    return _of$4(
      _class.reference.pointer,
      _id_of$4 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$5 = _class.staticMethodId(
    r'of',
    r'(IIIIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, int i1, int i2, int i3, int i4, int i5, int i6)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$5(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
  ) {
    return _of$5(
      _class.reference.pointer,
      _id_of$5 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$6 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;)Ljava/time/LocalDateTime;',
  );

  static final _of$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(java.time.LocalDate localDate, java.time.LocalTime localTime)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$6(LocalDate? localDate, LocalTime? localTime) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _of$6(
      _class.reference.pointer,
      _id_of$6 as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localTime.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/LocalDateTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(
    r'ofEpochSecond',
    r'(JILjava/time/ZoneOffset;)Ljava/time/LocalDateTime;',
  );

  static final _ofEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int64, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime ofEpochSecond(long j, int i, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? ofEpochSecond(int j, int i, ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _ofEpochSecond(
      _class.reference.pointer,
      _id_ofEpochSecond as jni$_.JMethodIDPtr,
      j,
      i,
      _$zoneOffset.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/LocalDateTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/LocalDateTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/LocalDateTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? toLocalDate() {
    return _toLocalDate(
      reference.pointer,
      _id_toLocalDate as jni$_.JMethodIDPtr,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() {
    return _getYear(
      reference.pointer,
      _id_getYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() {
    return _getMonthValue(
      reference.pointer,
      _id_getMonthValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() {
    return _getMonth(
      reference.pointer,
      _id_getMonth as jni$_.JMethodIDPtr,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() {
    return _getDayOfMonth(
      reference.pointer,
      _id_getDayOfMonth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() {
    return _getDayOfYear(
      reference.pointer,
      _id_getDayOfYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() {
    return _getDayOfWeek(
      reference.pointer,
      _id_getDayOfWeek as jni$_.JMethodIDPtr,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() {
    return _toLocalTime(
      reference.pointer,
      _id_toLocalTime as jni$_.JMethodIDPtr,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() {
    return _getHour(
      reference.pointer,
      _id_getHour as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() {
    return _getMinute(
      reference.pointer,
      _id_getMinute as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() {
    return _getSecond(
      reference.pointer,
      _id_getSecond as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/LocalDateTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/LocalDateTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withYear(int i) {
    return _withYear(
      reference.pointer,
      _id_withYear as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withMonth(int i) {
    return _withMonth(
      reference.pointer,
      _id_withMonth as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withDayOfMonth(int i) {
    return _withDayOfMonth(
      reference.pointer,
      _id_withDayOfMonth as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withDayOfYear(int i) {
    return _withDayOfYear(
      reference.pointer,
      _id_withDayOfYear as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withHour(int i) {
    return _withHour(
      reference.pointer,
      _id_withHour as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withMinute(int i) {
    return _withMinute(
      reference.pointer,
      _id_withMinute as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withSecond(int i) {
    return _withSecond(
      reference.pointer,
      _id_withSecond as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withNano(int i) {
    return _withNano(
      reference.pointer,
      _id_withNano as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/LocalDateTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDateTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDateTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusYears(int j) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusMonths(int j) {
    return _plusMonths(
      reference.pointer,
      _id_plusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusWeeks(int j) {
    return _plusWeeks(
      reference.pointer,
      _id_plusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusDays(int j) {
    return _plusDays(
      reference.pointer,
      _id_plusDays as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusHours(int j) {
    return _plusHours(
      reference.pointer,
      _id_plusHours as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusMinutes(int j) {
    return _plusMinutes(
      reference.pointer,
      _id_plusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDateTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDateTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusYears(int j) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusMonths(int j) {
    return _minusMonths(
      reference.pointer,
      _id_minusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusWeeks(int j) {
    return _minusWeeks(
      reference.pointer,
      _id_minusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusDays(int j) {
    return _minusDays(
      reference.pointer,
      _id_minusDays as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusHours(int j) {
    return _minusHours(
      reference.pointer,
      _id_minusHours as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusMinutes(int j) {
    return _minusMinutes(
      reference.pointer,
      _id_minusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atOffset(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_atZone = _class.instanceMethodId(
    r'atZone',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZone(
      reference.pointer,
      _id_atZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  int compareTo(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  bool isAfter(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  bool isBefore(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  bool isEqual(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $LocalDateTime$NullableType extends jni$_.JObjType<LocalDateTime?> {
  @jni$_.internal
  const $LocalDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDateTime;';

  @jni$_.internal
  @core$_.override
  LocalDateTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LocalDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LocalDateTime$NullableType) &&
        other is $LocalDateTime$NullableType;
  }
}

final class $LocalDateTime$Type extends jni$_.JObjType<LocalDateTime> {
  @jni$_.internal
  const $LocalDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDateTime;';

  @jni$_.internal
  @core$_.override
  LocalDateTime fromReference(jni$_.JReference reference) =>
      LocalDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDateTime?> get nullableType =>
      const $LocalDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LocalDateTime$Type) &&
        other is $LocalDateTime$Type;
  }
}

/// from: `java.time.Duration`
class Duration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Duration> $type;

  @jni$_.internal
  Duration.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Duration');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Duration$NullableType();
  static const type = $Duration$Type();
  static final _id_ZERO = _class.staticFieldId(
    r'ZERO',
    r'Ljava/time/Duration;',
  );

  /// from: `static public final java.time.Duration ZERO`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? get ZERO =>
      _id_ZERO.get(_class, const $Duration$NullableType());

  static final _id_ofDays = _class.staticMethodId(
    r'ofDays',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofDays(int j) {
    return _ofDays(
      _class.reference.pointer,
      _id_ofDays as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_ofHours = _class.staticMethodId(
    r'ofHours',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofHours(int j) {
    return _ofHours(
      _class.reference.pointer,
      _id_ofHours as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_ofMinutes = _class.staticMethodId(
    r'ofMinutes',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofMinutes(int j) {
    return _ofMinutes(
      _class.reference.pointer,
      _id_ofMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_ofSeconds = _class.staticMethodId(
    r'ofSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofSeconds(int j) {
    return _ofSeconds(
      _class.reference.pointer,
      _id_ofSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_ofSeconds$1 = _class.staticMethodId(
    r'ofSeconds',
    r'(JJ)Ljava/time/Duration;',
  );

  static final _ofSeconds$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofSeconds(long j, long j1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofSeconds$1(int j, int j1) {
    return _ofSeconds$1(
      _class.reference.pointer,
      _id_ofSeconds$1 as jni$_.JMethodIDPtr,
      j,
      j1,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_ofMillis = _class.staticMethodId(
    r'ofMillis',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofMillis(int j) {
    return _ofMillis(
      _class.reference.pointer,
      _id_ofMillis as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_ofNanos = _class.staticMethodId(
    r'ofNanos',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofNanos(int j) {
    return _ofNanos(
      _class.reference.pointer,
      _id_ofNanos as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration of(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? of(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Duration;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration from(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? from(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Duration;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_between = _class.staticMethodId(
    r'between',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/Temporal;)Ljava/time/Duration;',
  );

  static final _between =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration between(java.time.temporal.Temporal temporal, java.time.temporal.Temporal temporal1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? between(jni$_.JObject? temporal, jni$_.JObject? temporal1) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporal1 = temporal1?.reference ?? jni$_.jNullReference;
    return _between(
      _class.reference.pointer,
      _id_between as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporal1.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long get(java.time.temporal.TemporalUnit temporalUnit)`
  int get(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_getUnits = _class.instanceMethodId(
    r'getUnits',
    r'()Ljava/util/List;',
  );

  static final _getUnits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.time.temporal.TemporalUnit> getUnits()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getUnits() {
    return _getUnits(
      reference.pointer,
      _id_getUnits as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_isZero = _class.instanceMethodId(r'isZero', r'()Z');

  static final _isZero =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isZero()`
  bool isZero() {
    return _isZero(reference.pointer, _id_isZero as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isNegative = _class.instanceMethodId(r'isNegative', r'()Z');

  static final _isNegative =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isNegative()`
  bool isNegative() {
    return _isNegative(
      reference.pointer,
      _id_isNegative as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getSeconds = _class.instanceMethodId(r'getSeconds', r'()J');

  static final _getSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getSeconds()`
  int getSeconds() {
    return _getSeconds(
      reference.pointer,
      _id_getSeconds as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_withSeconds = _class.instanceMethodId(
    r'withSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _withSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration withSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? withSeconds(int j) {
    return _withSeconds(
      reference.pointer,
      _id_withSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_withNanos = _class.instanceMethodId(
    r'withNanos',
    r'(I)Ljava/time/Duration;',
  );

  static final _withNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration withNanos(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? withNanos(int i) {
    return _withNanos(
      reference.pointer,
      _id_withNanos as jni$_.JMethodIDPtr,
      i,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/Duration;)Ljava/time/Duration;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration plus(java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plus(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusDays(int j) {
    return _plusDays(
      reference.pointer,
      _id_plusDays as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusHours(int j) {
    return _plusHours(
      reference.pointer,
      _id_plusHours as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusMinutes(int j) {
    return _plusMinutes(
      reference.pointer,
      _id_plusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plusMillis = _class.instanceMethodId(
    r'plusMillis',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusMillis(int j) {
    return _plusMillis(
      reference.pointer,
      _id_plusMillis as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/Duration;)Ljava/time/Duration;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration minus(java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minus(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusDays(int j) {
    return _minusDays(
      reference.pointer,
      _id_minusDays as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusHours(int j) {
    return _minusHours(
      reference.pointer,
      _id_minusHours as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusMinutes(int j) {
    return _minusMinutes(
      reference.pointer,
      _id_minusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minusMillis = _class.instanceMethodId(
    r'minusMillis',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusMillis(int j) {
    return _minusMillis(
      reference.pointer,
      _id_minusMillis as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_multipliedBy = _class.instanceMethodId(
    r'multipliedBy',
    r'(J)Ljava/time/Duration;',
  );

  static final _multipliedBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration multipliedBy(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? multipliedBy(int j) {
    return _multipliedBy(
      reference.pointer,
      _id_multipliedBy as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_dividedBy = _class.instanceMethodId(
    r'dividedBy',
    r'(J)Ljava/time/Duration;',
  );

  static final _dividedBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration dividedBy(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? dividedBy(int j) {
    return _dividedBy(
      reference.pointer,
      _id_dividedBy as jni$_.JMethodIDPtr,
      j,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_dividedBy$1 = _class.instanceMethodId(
    r'dividedBy',
    r'(Ljava/time/Duration;)J',
  );

  static final _dividedBy$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long dividedBy(java.time.Duration duration)`
  int dividedBy$1(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _dividedBy$1(
      reference.pointer,
      _id_dividedBy$1 as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).long;
  }

  static final _id_negated = _class.instanceMethodId(
    r'negated',
    r'()Ljava/time/Duration;',
  );

  static final _negated =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Duration negated()`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? negated() {
    return _negated(
      reference.pointer,
      _id_negated as jni$_.JMethodIDPtr,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_abs = _class.instanceMethodId(
    r'abs',
    r'()Ljava/time/Duration;',
  );

  static final _abs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Duration abs()`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? abs() {
    return _abs(
      reference.pointer,
      _id_abs as jni$_.JMethodIDPtr,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_addTo = _class.instanceMethodId(
    r'addTo',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _addTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal addTo(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? addTo(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _addTo(
      reference.pointer,
      _id_addTo as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_subtractFrom = _class.instanceMethodId(
    r'subtractFrom',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _subtractFrom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? subtractFrom(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _subtractFrom(
      reference.pointer,
      _id_subtractFrom as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toDays = _class.instanceMethodId(r'toDays', r'()J');

  static final _toDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toDays()`
  int toDays() {
    return _toDays(reference.pointer, _id_toDays as jni$_.JMethodIDPtr).long;
  }

  static final _id_toHours = _class.instanceMethodId(r'toHours', r'()J');

  static final _toHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toHours()`
  int toHours() {
    return _toHours(reference.pointer, _id_toHours as jni$_.JMethodIDPtr).long;
  }

  static final _id_toMinutes = _class.instanceMethodId(r'toMinutes', r'()J');

  static final _toMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toMinutes()`
  int toMinutes() {
    return _toMinutes(
      reference.pointer,
      _id_toMinutes as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_toSeconds = _class.instanceMethodId(r'toSeconds', r'()J');

  static final _toSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toSeconds()`
  int toSeconds() {
    return _toSeconds(
      reference.pointer,
      _id_toSeconds as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_toMillis = _class.instanceMethodId(r'toMillis', r'()J');

  static final _toMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toMillis()`
  int toMillis() {
    return _toMillis(
      reference.pointer,
      _id_toMillis as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_toNanos = _class.instanceMethodId(r'toNanos', r'()J');

  static final _toNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toNanos()`
  int toNanos() {
    return _toNanos(reference.pointer, _id_toNanos as jni$_.JMethodIDPtr).long;
  }

  static final _id_toDaysPart = _class.instanceMethodId(r'toDaysPart', r'()J');

  static final _toDaysPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toDaysPart()`
  int toDaysPart() {
    return _toDaysPart(
      reference.pointer,
      _id_toDaysPart as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_toHoursPart = _class.instanceMethodId(
    r'toHoursPart',
    r'()I',
  );

  static final _toHoursPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toHoursPart()`
  int toHoursPart() {
    return _toHoursPart(
      reference.pointer,
      _id_toHoursPart as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toMinutesPart = _class.instanceMethodId(
    r'toMinutesPart',
    r'()I',
  );

  static final _toMinutesPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toMinutesPart()`
  int toMinutesPart() {
    return _toMinutesPart(
      reference.pointer,
      _id_toMinutesPart as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toSecondsPart = _class.instanceMethodId(
    r'toSecondsPart',
    r'()I',
  );

  static final _toSecondsPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toSecondsPart()`
  int toSecondsPart() {
    return _toSecondsPart(
      reference.pointer,
      _id_toSecondsPart as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toMillisPart = _class.instanceMethodId(
    r'toMillisPart',
    r'()I',
  );

  static final _toMillisPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toMillisPart()`
  int toMillisPart() {
    return _toMillisPart(
      reference.pointer,
      _id_toMillisPart as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toNanosPart = _class.instanceMethodId(
    r'toNanosPart',
    r'()I',
  );

  static final _toNanosPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toNanosPart()`
  int toNanosPart() {
    return _toNanosPart(
      reference.pointer,
      _id_toNanosPart as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Duration;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.Duration duration)`
  int compareTo(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(Duration? duration) {
    return compareTo(duration) < 0;
  }

  bool operator <=(Duration? duration) {
    return compareTo(duration) <= 0;
  }

  bool operator >(Duration? duration) {
    return compareTo(duration) > 0;
  }

  bool operator >=(Duration? duration) {
    return compareTo(duration) >= 0;
  }
}

final class $Duration$NullableType extends jni$_.JObjType<Duration?> {
  @jni$_.internal
  const $Duration$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Duration;';

  @jni$_.internal
  @core$_.override
  Duration? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Duration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Duration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Duration$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Duration$NullableType) &&
        other is $Duration$NullableType;
  }
}

final class $Duration$Type extends jni$_.JObjType<Duration> {
  @jni$_.internal
  const $Duration$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Duration;';

  @jni$_.internal
  @core$_.override
  Duration fromReference(jni$_.JReference reference) =>
      Duration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Duration?> get nullableType => const $Duration$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Duration$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Duration$Type) && other is $Duration$Type;
  }
}

/// from: `java.time.LocalTime`
class LocalTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LocalTime> $type;

  @jni$_.internal
  LocalTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/LocalTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LocalTime$NullableType();
  static const type = $LocalTime$Type();
  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/LocalTime;');

  /// from: `static public final java.time.LocalTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get MIN =>
      _id_MIN.get(_class, const $LocalTime$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/LocalTime;');

  /// from: `static public final java.time.LocalTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get MAX =>
      _id_MAX.get(_class, const $LocalTime$NullableType());

  static final _id_MIDNIGHT = _class.staticFieldId(
    r'MIDNIGHT',
    r'Ljava/time/LocalTime;',
  );

  /// from: `static public final java.time.LocalTime MIDNIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get MIDNIGHT =>
      _id_MIDNIGHT.get(_class, const $LocalTime$NullableType());

  static final _id_NOON = _class.staticFieldId(
    r'NOON',
    r'Ljava/time/LocalTime;',
  );

  /// from: `static public final java.time.LocalTime NOON`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get NOON =>
      _id_NOON.get(_class, const $LocalTime$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/LocalTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.LocalTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/LocalTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/LocalTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(II)Ljava/time/LocalTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime of(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? of(int i, int i1) {
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(III)Ljava/time/LocalTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime of(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? of$1(int i, int i1, int i2) {
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(IIII)Ljava/time/LocalTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime of(int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? of$2(int i, int i1, int i2, int i3) {
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/LocalTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_ofSecondOfDay = _class.staticMethodId(
    r'ofSecondOfDay',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _ofSecondOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime ofSecondOfDay(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? ofSecondOfDay(int j) {
    return _ofSecondOfDay(
      _class.reference.pointer,
      _id_ofSecondOfDay as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_ofNanoOfDay = _class.staticMethodId(
    r'ofNanoOfDay',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _ofNanoOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime ofNanoOfDay(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? ofNanoOfDay(int j) {
    return _ofNanoOfDay(
      _class.reference.pointer,
      _id_ofNanoOfDay as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/LocalTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/LocalTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/LocalTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() {
    return _getHour(
      reference.pointer,
      _id_getHour as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() {
    return _getMinute(
      reference.pointer,
      _id_getMinute as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() {
    return _getSecond(
      reference.pointer,
      _id_getSecond as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/LocalTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/LocalTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.LocalTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withHour(int i) {
    return _withHour(
      reference.pointer,
      _id_withHour as jni$_.JMethodIDPtr,
      i,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withMinute(int i) {
    return _withMinute(
      reference.pointer,
      _id_withMinute as jni$_.JMethodIDPtr,
      i,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withSecond(int i) {
    return _withSecond(
      reference.pointer,
      _id_withSecond as jni$_.JMethodIDPtr,
      i,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withNano(int i) {
    return _withNano(
      reference.pointer,
      _id_withNano as jni$_.JMethodIDPtr,
      i,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/LocalTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusHours(int j) {
    return _plusHours(
      reference.pointer,
      _id_plusHours as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusMinutes(int j) {
    return _plusMinutes(
      reference.pointer,
      _id_plusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusHours(int j) {
    return _minusHours(
      reference.pointer,
      _id_minusHours as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusMinutes(int j) {
    return _minusMinutes(
      reference.pointer,
      _id_minusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDate = _class.instanceMethodId(
    r'atDate',
    r'(Ljava/time/LocalDate;)Ljava/time/LocalDateTime;',
  );

  static final _atDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime atDate(java.time.LocalDate localDate)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atDate(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _atDate(
      reference.pointer,
      _id_atDate as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? atOffset(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_toSecondOfDay = _class.instanceMethodId(
    r'toSecondOfDay',
    r'()I',
  );

  static final _toSecondOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toSecondOfDay()`
  int toSecondOfDay() {
    return _toSecondOfDay(
      reference.pointer,
      _id_toSecondOfDay as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toNanoOfDay = _class.instanceMethodId(
    r'toNanoOfDay',
    r'()J',
  );

  static final _toNanoOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toNanoOfDay()`
  int toNanoOfDay() {
    return _toNanoOfDay(
      reference.pointer,
      _id_toNanoOfDay as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'(Ljava/time/LocalDate;Ljava/time/ZoneOffset;)J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long toEpochSecond(java.time.LocalDate localDate, java.time.ZoneOffset zoneOffset)`
  int toEpochSecond(LocalDate? localDate, ZoneOffset? zoneOffset) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _toEpochSecond(
      reference.pointer,
      _id_toEpochSecond as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$zoneOffset.pointer,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/LocalTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.LocalTime localTime)`
  int compareTo(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/LocalTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.LocalTime localTime)`
  bool isAfter(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/LocalTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.LocalTime localTime)`
  bool isBefore(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(LocalTime? localTime) {
    return compareTo(localTime) < 0;
  }

  bool operator <=(LocalTime? localTime) {
    return compareTo(localTime) <= 0;
  }

  bool operator >(LocalTime? localTime) {
    return compareTo(localTime) > 0;
  }

  bool operator >=(LocalTime? localTime) {
    return compareTo(localTime) >= 0;
  }
}

final class $LocalTime$NullableType extends jni$_.JObjType<LocalTime?> {
  @jni$_.internal
  const $LocalTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalTime;';

  @jni$_.internal
  @core$_.override
  LocalTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LocalTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LocalTime$NullableType) &&
        other is $LocalTime$NullableType;
  }
}

final class $LocalTime$Type extends jni$_.JObjType<LocalTime> {
  @jni$_.internal
  const $LocalTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalTime;';

  @jni$_.internal
  @core$_.override
  LocalTime fromReference(jni$_.JReference reference) =>
      LocalTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalTime?> get nullableType =>
      const $LocalTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LocalTime$Type) && other is $LocalTime$Type;
  }
}

/// from: `java.time.ZoneOffset`
class ZoneOffset extends ZoneId {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneOffset> $type;

  @jni$_.internal
  ZoneOffset.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneOffset');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneOffset$NullableType();
  static const type = $ZoneOffset$Type();
  static final _id_UTC = _class.staticFieldId(
    r'UTC',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset UTC`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get UTC =>
      _id_UTC.get(_class, const $ZoneOffset$NullableType());

  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get MIN =>
      _id_MIN.get(_class, const $ZoneOffset$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get MAX =>
      _id_MAX.get(_class, const $ZoneOffset$NullableType());

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/time/ZoneOffset;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneOffset of(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? of$2(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHours = _class.staticMethodId(
    r'ofHours',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofHours(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHours(int i) {
    return _ofHours(
      _class.reference.pointer,
      _id_ofHours as jni$_.JMethodIDPtr,
      i,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutes = _class.staticMethodId(
    r'ofHoursMinutes',
    r'(II)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofHoursMinutes(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHoursMinutes(int i, int i1) {
    return _ofHoursMinutes(
      _class.reference.pointer,
      _id_ofHoursMinutes as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutesSeconds = _class.staticMethodId(
    r'ofHoursMinutesSeconds',
    r'(III)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutesSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofHoursMinutesSeconds(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHoursMinutesSeconds(int i, int i1, int i2) {
    return _ofHoursMinutesSeconds(
      _class.reference.pointer,
      _id_ofHoursMinutesSeconds as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_from$1 = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneOffset;',
  );

  static final _from$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneOffset from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? from$1(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from$1(
      _class.reference.pointer,
      _id_from$1 as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofTotalSeconds = _class.staticMethodId(
    r'ofTotalSeconds',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofTotalSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofTotalSeconds(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofTotalSeconds(int i) {
    return _ofTotalSeconds(
      _class.reference.pointer,
      _id_ofTotalSeconds as jni$_.JMethodIDPtr,
      i,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_getTotalSeconds = _class.instanceMethodId(
    r'getTotalSeconds',
    r'()I',
  );

  static final _getTotalSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTotalSeconds()`
  int getTotalSeconds() {
    return _getTotalSeconds(
      reference.pointer,
      _id_getTotalSeconds as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() {
    return _getId(
      reference.pointer,
      _id_getId as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/time/zone/ZoneRules;',
  );

  static final _getRules =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRules() {
    return _getRules(
      reference.pointer,
      _id_getRules as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/ZoneOffset;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.ZoneOffset zoneOffset)`
  int compareTo(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() {
    return _hashCode1(
      reference.pointer,
      _id_hashCode1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString1() {
    return _toString1(
      reference.pointer,
      _id_toString1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) < 0;
  }

  bool operator <=(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) <= 0;
  }

  bool operator >(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) > 0;
  }

  bool operator >=(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) >= 0;
  }
}

final class $ZoneOffset$NullableType extends jni$_.JObjType<ZoneOffset?> {
  @jni$_.internal
  const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZoneOffset.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$NullableType) &&
        other is $ZoneOffset$NullableType;
  }
}

final class $ZoneOffset$Type extends jni$_.JObjType<ZoneOffset> {
  @jni$_.internal
  const $ZoneOffset$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset fromReference(jni$_.JReference reference) =>
      ZoneOffset.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType =>
      const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$Type) && other is $ZoneOffset$Type;
  }
}

/// from: `java.time.DateTimeException`
class DateTimeException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DateTimeException> $type;

  @jni$_.internal
  DateTimeException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/DateTimeException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DateTimeException$NullableType();
  static const type = $DateTimeException$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DateTimeException(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return DateTimeException.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Throwable;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DateTimeException.new$1(
    jni$_.JString? string,
    jni$_.JObject? throwable,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return DateTimeException.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$throwable.pointer,
      ).reference,
    );
  }
}

final class $DateTimeException$NullableType
    extends jni$_.JObjType<DateTimeException?> {
  @jni$_.internal
  const $DateTimeException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DateTimeException;';

  @jni$_.internal
  @core$_.override
  DateTimeException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DateTimeException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateTimeException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateTimeException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DateTimeException$NullableType) &&
        other is $DateTimeException$NullableType;
  }
}

final class $DateTimeException$Type extends jni$_.JObjType<DateTimeException> {
  @jni$_.internal
  const $DateTimeException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DateTimeException;';

  @jni$_.internal
  @core$_.override
  DateTimeException fromReference(jni$_.JReference reference) =>
      DateTimeException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateTimeException?> get nullableType =>
      const $DateTimeException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateTimeException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DateTimeException$Type) &&
        other is $DateTimeException$Type;
  }
}

/// from: `java.time.OffsetTime`
class OffsetTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OffsetTime> $type;

  @jni$_.internal
  OffsetTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/OffsetTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OffsetTime$NullableType();
  static const type = $OffsetTime$Type();
  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/OffsetTime;',
  );

  /// from: `static public final java.time.OffsetTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? get MIN =>
      _id_MIN.get(_class, const $OffsetTime$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/OffsetTime;',
  );

  /// from: `static public final java.time.OffsetTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? get MAX =>
      _id_MAX.get(_class, const $OffsetTime$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/OffsetTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.OffsetTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/OffsetTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/OffsetTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalTime;Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime of(java.time.LocalTime localTime, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? of(LocalTime? localTime, ZoneOffset? zoneOffset) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$localTime.pointer,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(IIIILjava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime of(int i, int i1, int i2, int i3, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? of$1(
    int i,
    int i1,
    int i2,
    int i3,
    ZoneOffset? zoneOffset,
  ) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/OffsetTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/OffsetTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/OffsetTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/OffsetTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneOffset? getOffset() {
    return _getOffset(
      reference.pointer,
      _id_getOffset as jni$_.JMethodIDPtr,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_withOffsetSameLocal = _class.instanceMethodId(
    r'withOffsetSameLocal',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _withOffsetSameLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime withOffsetSameLocal(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withOffsetSameLocal(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameLocal(
      reference.pointer,
      _id_withOffsetSameLocal as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_withOffsetSameInstant = _class.instanceMethodId(
    r'withOffsetSameInstant',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _withOffsetSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime withOffsetSameInstant(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withOffsetSameInstant(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameInstant(
      reference.pointer,
      _id_withOffsetSameInstant as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() {
    return _toLocalTime(
      reference.pointer,
      _id_toLocalTime as jni$_.JMethodIDPtr,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() {
    return _getHour(
      reference.pointer,
      _id_getHour as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() {
    return _getMinute(
      reference.pointer,
      _id_getMinute as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() {
    return _getSecond(
      reference.pointer,
      _id_getSecond as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/OffsetTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/OffsetTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withHour(int i) {
    return _withHour(
      reference.pointer,
      _id_withHour as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withMinute(int i) {
    return _withMinute(
      reference.pointer,
      _id_withMinute as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withSecond(int i) {
    return _withSecond(
      reference.pointer,
      _id_withSecond as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withNano(int i) {
    return _withNano(
      reference.pointer,
      _id_withNano as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/OffsetTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusHours(int j) {
    return _plusHours(
      reference.pointer,
      _id_plusHours as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusMinutes(int j) {
    return _plusMinutes(
      reference.pointer,
      _id_plusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusHours(int j) {
    return _minusHours(
      reference.pointer,
      _id_minusHours as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusMinutes(int j) {
    return _minusMinutes(
      reference.pointer,
      _id_minusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDate = _class.instanceMethodId(
    r'atDate',
    r'(Ljava/time/LocalDate;)Ljava/time/OffsetDateTime;',
  );

  static final _atDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atDate(java.time.LocalDate localDate)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atDate(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _atDate(
      reference.pointer,
      _id_atDate as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'(Ljava/time/LocalDate;)J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long toEpochSecond(java.time.LocalDate localDate)`
  int toEpochSecond(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _toEpochSecond(
      reference.pointer,
      _id_toEpochSecond as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/OffsetTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.OffsetTime offsetTime)`
  int compareTo(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/OffsetTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.OffsetTime offsetTime)`
  bool isAfter(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/OffsetTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.OffsetTime offsetTime)`
  bool isBefore(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/OffsetTime;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.OffsetTime offsetTime)`
  bool isEqual(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(OffsetTime? offsetTime) {
    return compareTo(offsetTime) < 0;
  }

  bool operator <=(OffsetTime? offsetTime) {
    return compareTo(offsetTime) <= 0;
  }

  bool operator >(OffsetTime? offsetTime) {
    return compareTo(offsetTime) > 0;
  }

  bool operator >=(OffsetTime? offsetTime) {
    return compareTo(offsetTime) >= 0;
  }
}

final class $OffsetTime$NullableType extends jni$_.JObjType<OffsetTime?> {
  @jni$_.internal
  const $OffsetTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetTime;';

  @jni$_.internal
  @core$_.override
  OffsetTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OffsetTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OffsetTime$NullableType) &&
        other is $OffsetTime$NullableType;
  }
}

final class $OffsetTime$Type extends jni$_.JObjType<OffsetTime> {
  @jni$_.internal
  const $OffsetTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetTime;';

  @jni$_.internal
  @core$_.override
  OffsetTime fromReference(jni$_.JReference reference) =>
      OffsetTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetTime?> get nullableType =>
      const $OffsetTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OffsetTime$Type) && other is $OffsetTime$Type;
  }
}

/// from: `java.time.Period`
class Period extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Period> $type;

  @jni$_.internal
  Period.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Period');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Period$NullableType();
  static const type = $Period$Type();
  static final _id_ZERO = _class.staticFieldId(r'ZERO', r'Ljava/time/Period;');

  /// from: `static public final java.time.Period ZERO`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? get ZERO => _id_ZERO.get(_class, const $Period$NullableType());

  static final _id_ofYears = _class.staticMethodId(
    r'ofYears',
    r'(I)Ljava/time/Period;',
  );

  static final _ofYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofYears(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofYears(int i) {
    return _ofYears(
      _class.reference.pointer,
      _id_ofYears as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_ofMonths = _class.staticMethodId(
    r'ofMonths',
    r'(I)Ljava/time/Period;',
  );

  static final _ofMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofMonths(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofMonths(int i) {
    return _ofMonths(
      _class.reference.pointer,
      _id_ofMonths as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_ofWeeks = _class.staticMethodId(
    r'ofWeeks',
    r'(I)Ljava/time/Period;',
  );

  static final _ofWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofWeeks(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofWeeks(int i) {
    return _ofWeeks(
      _class.reference.pointer,
      _id_ofWeeks as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_ofDays = _class.staticMethodId(
    r'ofDays',
    r'(I)Ljava/time/Period;',
  );

  static final _ofDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofDays(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofDays(int i) {
    return _ofDays(
      _class.reference.pointer,
      _id_ofDays as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(III)Ljava/time/Period;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.Period of(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? of(int i, int i1, int i2) {
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Period;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Period from(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? from(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Period;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Period parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_between = _class.staticMethodId(
    r'between',
    r'(Ljava/time/LocalDate;Ljava/time/LocalDate;)Ljava/time/Period;',
  );

  static final _between =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Period between(java.time.LocalDate localDate, java.time.LocalDate localDate1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? between(LocalDate? localDate, LocalDate? localDate1) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localDate1 = localDate1?.reference ?? jni$_.jNullReference;
    return _between(
      _class.reference.pointer,
      _id_between as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localDate1.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long get(java.time.temporal.TemporalUnit temporalUnit)`
  int get(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_getUnits = _class.instanceMethodId(
    r'getUnits',
    r'()Ljava/util/List;',
  );

  static final _getUnits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.time.temporal.TemporalUnit> getUnits()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getUnits() {
    return _getUnits(
      reference.pointer,
      _id_getUnits as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_getChronology = _class.instanceMethodId(
    r'getChronology',
    r'()Ljava/time/chrono/IsoChronology;',
  );

  static final _getChronology =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.chrono.IsoChronology getChronology()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChronology() {
    return _getChronology(
      reference.pointer,
      _id_getChronology as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isZero = _class.instanceMethodId(r'isZero', r'()Z');

  static final _isZero =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isZero()`
  bool isZero() {
    return _isZero(reference.pointer, _id_isZero as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isNegative = _class.instanceMethodId(r'isNegative', r'()Z');

  static final _isNegative =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isNegative()`
  bool isNegative() {
    return _isNegative(
      reference.pointer,
      _id_isNegative as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getYears = _class.instanceMethodId(r'getYears', r'()I');

  static final _getYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYears()`
  int getYears() {
    return _getYears(
      reference.pointer,
      _id_getYears as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonths = _class.instanceMethodId(r'getMonths', r'()I');

  static final _getMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonths()`
  int getMonths() {
    return _getMonths(
      reference.pointer,
      _id_getMonths as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDays = _class.instanceMethodId(r'getDays', r'()I');

  static final _getDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDays()`
  int getDays() {
    return _getDays(
      reference.pointer,
      _id_getDays as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_withYears = _class.instanceMethodId(
    r'withYears',
    r'(I)Ljava/time/Period;',
  );

  static final _withYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period withYears(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? withYears(int i) {
    return _withYears(
      reference.pointer,
      _id_withYears as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_withMonths = _class.instanceMethodId(
    r'withMonths',
    r'(I)Ljava/time/Period;',
  );

  static final _withMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period withMonths(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? withMonths(int i) {
    return _withMonths(
      reference.pointer,
      _id_withMonths as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_withDays = _class.instanceMethodId(
    r'withDays',
    r'(I)Ljava/time/Period;',
  );

  static final _withDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period withDays(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? withDays(int i) {
    return _withDays(
      reference.pointer,
      _id_withDays as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Period;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Period plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/Period;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plusYears(int j) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      j,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/Period;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plusMonths(int j) {
    return _plusMonths(
      reference.pointer,
      _id_plusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/Period;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plusDays(int j) {
    return _plusDays(
      reference.pointer,
      _id_plusDays as jni$_.JMethodIDPtr,
      j,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Period;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Period minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/Period;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minusYears(int j) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      j,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/Period;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minusMonths(int j) {
    return _minusMonths(
      reference.pointer,
      _id_minusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/Period;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minusDays(int j) {
    return _minusDays(
      reference.pointer,
      _id_minusDays as jni$_.JMethodIDPtr,
      j,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_multipliedBy = _class.instanceMethodId(
    r'multipliedBy',
    r'(I)Ljava/time/Period;',
  );

  static final _multipliedBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period multipliedBy(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? multipliedBy(int i) {
    return _multipliedBy(
      reference.pointer,
      _id_multipliedBy as jni$_.JMethodIDPtr,
      i,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_negated = _class.instanceMethodId(
    r'negated',
    r'()Ljava/time/Period;',
  );

  static final _negated =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Period negated()`
  /// The returned object must be released after use, by calling the [release] method.
  Period? negated() {
    return _negated(
      reference.pointer,
      _id_negated as jni$_.JMethodIDPtr,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_normalized = _class.instanceMethodId(
    r'normalized',
    r'()Ljava/time/Period;',
  );

  static final _normalized =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Period normalized()`
  /// The returned object must be released after use, by calling the [release] method.
  Period? normalized() {
    return _normalized(
      reference.pointer,
      _id_normalized as jni$_.JMethodIDPtr,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_toTotalMonths = _class.instanceMethodId(
    r'toTotalMonths',
    r'()J',
  );

  static final _toTotalMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toTotalMonths()`
  int toTotalMonths() {
    return _toTotalMonths(
      reference.pointer,
      _id_toTotalMonths as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_addTo = _class.instanceMethodId(
    r'addTo',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _addTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal addTo(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? addTo(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _addTo(
      reference.pointer,
      _id_addTo as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_subtractFrom = _class.instanceMethodId(
    r'subtractFrom',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _subtractFrom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? subtractFrom(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _subtractFrom(
      reference.pointer,
      _id_subtractFrom as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Period$NullableType extends jni$_.JObjType<Period?> {
  @jni$_.internal
  const $Period$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Period;';

  @jni$_.internal
  @core$_.override
  Period? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Period.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Period?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Period$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Period$NullableType) &&
        other is $Period$NullableType;
  }
}

final class $Period$Type extends jni$_.JObjType<Period> {
  @jni$_.internal
  const $Period$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Period;';

  @jni$_.internal
  @core$_.override
  Period fromReference(jni$_.JReference reference) =>
      Period.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Period?> get nullableType => const $Period$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Period$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Period$Type) && other is $Period$Type;
  }
}

/// from: `java.time.Month`
class Month extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Month> $type;

  @jni$_.internal
  Month.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Month');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Month$NullableType();
  static const type = $Month$Type();
  static final _id_JANUARY = _class.staticFieldId(
    r'JANUARY',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month JANUARY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get JANUARY => _id_JANUARY.get(_class, const $Month$Type());

  static final _id_FEBRUARY = _class.staticFieldId(
    r'FEBRUARY',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month FEBRUARY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get FEBRUARY => _id_FEBRUARY.get(_class, const $Month$Type());

  static final _id_MARCH = _class.staticFieldId(r'MARCH', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month MARCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get MARCH => _id_MARCH.get(_class, const $Month$Type());

  static final _id_APRIL = _class.staticFieldId(r'APRIL', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month APRIL`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get APRIL => _id_APRIL.get(_class, const $Month$Type());

  static final _id_MAY = _class.staticFieldId(r'MAY', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month MAY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get MAY => _id_MAY.get(_class, const $Month$Type());

  static final _id_JUNE = _class.staticFieldId(r'JUNE', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month JUNE`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get JUNE => _id_JUNE.get(_class, const $Month$Type());

  static final _id_JULY = _class.staticFieldId(r'JULY', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month JULY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get JULY => _id_JULY.get(_class, const $Month$Type());

  static final _id_AUGUST = _class.staticFieldId(
    r'AUGUST',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month AUGUST`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get AUGUST => _id_AUGUST.get(_class, const $Month$Type());

  static final _id_SEPTEMBER = _class.staticFieldId(
    r'SEPTEMBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month SEPTEMBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get SEPTEMBER => _id_SEPTEMBER.get(_class, const $Month$Type());

  static final _id_OCTOBER = _class.staticFieldId(
    r'OCTOBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month OCTOBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get OCTOBER => _id_OCTOBER.get(_class, const $Month$Type());

  static final _id_NOVEMBER = _class.staticFieldId(
    r'NOVEMBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month NOVEMBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get NOVEMBER => _id_NOVEMBER.get(_class, const $Month$Type());

  static final _id_DECEMBER = _class.staticFieldId(
    r'DECEMBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month DECEMBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get DECEMBER => _id_DECEMBER.get(_class, const $Month$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/time/Month;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Month[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Month?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Month?>?>(
      const jni$_.JArrayNullableType<Month?>($Month$NullableType()),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/time/Month;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Month valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Month? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_of = _class.staticMethodId(r'of', r'(I)Ljava/time/Month;');

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Month of(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Month? of(int i) {
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Month;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Month from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Month? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_getValue = _class.instanceMethodId(r'getValue', r'()I');

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getValue()`
  int getValue() {
    return _getValue(
      reference.pointer,
      _id_getValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle textStyle, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName(
    jni$_.JObject? textStyle,
    jni$_.JObject? locale,
  ) {
    final _$textStyle = textStyle?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
      _$textStyle.pointer,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(J)Ljava/time/Month;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Month plus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Month? plus(int j) {
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      j,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(J)Ljava/time/Month;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Month minus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Month? minus(int j) {
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      j,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_length = _class.instanceMethodId(r'length', r'(Z)I');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int length(boolean z)`
  int length(bool z) {
    return _length(
      reference.pointer,
      _id_length as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).integer;
  }

  static final _id_minLength = _class.instanceMethodId(r'minLength', r'()I');

  static final _minLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int minLength()`
  int minLength() {
    return _minLength(
      reference.pointer,
      _id_minLength as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_maxLength = _class.instanceMethodId(r'maxLength', r'()I');

  static final _maxLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int maxLength()`
  int maxLength() {
    return _maxLength(
      reference.pointer,
      _id_maxLength as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_firstDayOfYear = _class.instanceMethodId(
    r'firstDayOfYear',
    r'(Z)I',
  );

  static final _firstDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int firstDayOfYear(boolean z)`
  int firstDayOfYear(bool z) {
    return _firstDayOfYear(
      reference.pointer,
      _id_firstDayOfYear as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).integer;
  }

  static final _id_firstMonthOfQuarter = _class.instanceMethodId(
    r'firstMonthOfQuarter',
    r'()Ljava/time/Month;',
  );

  static final _firstMonthOfQuarter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month firstMonthOfQuarter()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? firstMonthOfQuarter() {
    return _firstMonthOfQuarter(
      reference.pointer,
      _id_firstMonthOfQuarter as jni$_.JMethodIDPtr,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $Month$NullableType extends jni$_.JObjType<Month?> {
  @jni$_.internal
  const $Month$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Month;';

  @jni$_.internal
  @core$_.override
  Month? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Month.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Month?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Month$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Month$NullableType) &&
        other is $Month$NullableType;
  }
}

final class $Month$Type extends jni$_.JObjType<Month> {
  @jni$_.internal
  const $Month$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Month;';

  @jni$_.internal
  @core$_.override
  Month fromReference(jni$_.JReference reference) =>
      Month.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Month?> get nullableType => const $Month$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Month$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Month$Type) && other is $Month$Type;
  }
}

/// from: `java.time.MonthDay`
class MonthDay extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MonthDay> $type;

  @jni$_.internal
  MonthDay.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/MonthDay');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MonthDay$NullableType();
  static const type = $MonthDay$Type();
  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/MonthDay;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.MonthDay now()`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/MonthDay;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/MonthDay;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/Month;I)Ljava/time/MonthDay;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.time.MonthDay of(java.time.Month month, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? of(Month? month, int i) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$month.pointer,
      i,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(II)Ljava/time/MonthDay;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.MonthDay of(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? of$1(int i, int i1) {
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/MonthDay;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/MonthDay;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/MonthDay;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() {
    return _getMonthValue(
      reference.pointer,
      _id_getMonthValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() {
    return _getMonth(
      reference.pointer,
      _id_getMonth as jni$_.JMethodIDPtr,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() {
    return _getDayOfMonth(
      reference.pointer,
      _id_getDayOfMonth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isValidYear = _class.instanceMethodId(
    r'isValidYear',
    r'(I)Z',
  );

  static final _isValidYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isValidYear(int i)`
  bool isValidYear(int i) {
    return _isValidYear(
      reference.pointer,
      _id_isValidYear as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/MonthDay;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.MonthDay withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MonthDay? withMonth(int i) {
    return _withMonth(
      reference.pointer,
      _id_withMonth as jni$_.JMethodIDPtr,
      i,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/Month;)Ljava/time/MonthDay;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.MonthDay with(java.time.Month month)`
  /// The returned object must be released after use, by calling the [release] method.
  MonthDay? with$(Month? month) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$month.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/MonthDay;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.MonthDay withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MonthDay? withDayOfMonth(int i) {
    return _withDayOfMonth(
      reference.pointer,
      _id_withDayOfMonth as jni$_.JMethodIDPtr,
      i,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atYear = _class.instanceMethodId(
    r'atYear',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _atYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate atYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atYear(int i) {
    return _atYear(
      reference.pointer,
      _id_atYear as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/MonthDay;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.MonthDay monthDay)`
  int compareTo(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/MonthDay;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.MonthDay monthDay)`
  bool isAfter(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/MonthDay;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.MonthDay monthDay)`
  bool isBefore(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(MonthDay? monthDay) {
    return compareTo(monthDay) < 0;
  }

  bool operator <=(MonthDay? monthDay) {
    return compareTo(monthDay) <= 0;
  }

  bool operator >(MonthDay? monthDay) {
    return compareTo(monthDay) > 0;
  }

  bool operator >=(MonthDay? monthDay) {
    return compareTo(monthDay) >= 0;
  }
}

final class $MonthDay$NullableType extends jni$_.JObjType<MonthDay?> {
  @jni$_.internal
  const $MonthDay$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/MonthDay;';

  @jni$_.internal
  @core$_.override
  MonthDay? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : MonthDay.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MonthDay?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MonthDay$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MonthDay$NullableType) &&
        other is $MonthDay$NullableType;
  }
}

final class $MonthDay$Type extends jni$_.JObjType<MonthDay> {
  @jni$_.internal
  const $MonthDay$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/MonthDay;';

  @jni$_.internal
  @core$_.override
  MonthDay fromReference(jni$_.JReference reference) =>
      MonthDay.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MonthDay?> get nullableType => const $MonthDay$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MonthDay$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MonthDay$Type) && other is $MonthDay$Type;
  }
}

/// from: `java.time.Instant`
class Instant extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Instant> $type;

  @jni$_.internal
  Instant.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Instant');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Instant$NullableType();
  static const type = $Instant$Type();
  static final _id_EPOCH = _class.staticFieldId(
    r'EPOCH',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get EPOCH =>
      _id_EPOCH.get(_class, const $Instant$NullableType());

  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MIN => _id_MIN.get(_class, const $Instant$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MAX => _id_MAX.get(_class, const $Instant$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/Instant;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Instant now()`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/Instant;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now$1(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(
    r'ofEpochSecond',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochSecond(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond(int j) {
    return _ofEpochSecond(
      _class.reference.pointer,
      _id_ofEpochSecond as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond$1 = _class.staticMethodId(
    r'ofEpochSecond',
    r'(JJ)Ljava/time/Instant;',
  );

  static final _ofEpochSecond$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochSecond(long j, long j1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond$1(int j, int j1) {
    return _ofEpochSecond$1(
      _class.reference.pointer,
      _id_ofEpochSecond$1 as jni$_.JMethodIDPtr,
      j,
      j1,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochMilli = _class.staticMethodId(
    r'ofEpochMilli',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochMilli(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochMilli(int j) {
    return _ofEpochMilli(
      _class.reference.pointer,
      _id_ofEpochMilli as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Instant;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Instant;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getEpochSecond = _class.instanceMethodId(
    r'getEpochSecond',
    r'()J',
  );

  static final _getEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getEpochSecond()`
  int getEpochSecond() {
    return _getEpochSecond(
      reference.pointer,
      _id_getEpochSecond as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Instant;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Instant;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusMillis = _class.instanceMethodId(
    r'plusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusMillis(int j) {
    return _plusMillis(
      reference.pointer,
      _id_plusMillis as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusMillis = _class.instanceMethodId(
    r'minusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusMillis(int j) {
    return _minusMillis(
      reference.pointer,
      _id_minusMillis as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atOffset(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_atZone = _class.instanceMethodId(
    r'atZone',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZone(
      reference.pointer,
      _id_atZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toEpochMilli = _class.instanceMethodId(
    r'toEpochMilli',
    r'()J',
  );

  static final _toEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toEpochMilli()`
  int toEpochMilli() {
    return _toEpochMilli(
      reference.pointer,
      _id_toEpochMilli as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Instant;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.Instant instant)`
  int compareTo(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.Instant instant)`
  bool isAfter(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.Instant instant)`
  bool isBefore(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(Instant? instant) {
    return compareTo(instant) < 0;
  }

  bool operator <=(Instant? instant) {
    return compareTo(instant) <= 0;
  }

  bool operator >(Instant? instant) {
    return compareTo(instant) > 0;
  }

  bool operator >=(Instant? instant) {
    return compareTo(instant) >= 0;
  }
}

final class $Instant$NullableType extends jni$_.JObjType<Instant?> {
  @jni$_.internal
  const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$NullableType) &&
        other is $Instant$NullableType;
  }
}

final class $Instant$Type extends jni$_.JObjType<Instant> {
  @jni$_.internal
  const $Instant$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant fromReference(jni$_.JReference reference) =>
      Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$Type) && other is $Instant$Type;
  }
}

/// from: `java.time.ZoneId`
class ZoneId extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneId> $type;

  @jni$_.internal
  ZoneId.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneId');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneId$NullableType();
  static const type = $ZoneId$Type();
  static final _id_SHORT_IDS = _class.staticFieldId(
    r'SHORT_IDS',
    r'Ljava/util/Map;',
  );

  /// from: `static public final java.util.Map<java.lang.String, java.lang.String> SHORT_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JString?>? get SHORT_IDS =>
      _id_SHORT_IDS.get(
        _class,
        const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(),
          jni$_.JStringNullableType(),
        ),
      );

  static final _id_systemDefault = _class.staticMethodId(
    r'systemDefault',
    r'()Ljava/time/ZoneId;',
  );

  static final _systemDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.ZoneId systemDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? systemDefault() {
    return _systemDefault(
      _class.reference.pointer,
      _id_systemDefault as jni$_.JMethodIDPtr,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_getAvailableZoneIds = _class.staticMethodId(
    r'getAvailableZoneIds',
    r'()Ljava/util/Set;',
  );

  static final _getAvailableZoneIds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Set<java.lang.String> getAvailableZoneIds()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JSet<jni$_.JString?>? getAvailableZoneIds() {
    return _getAvailableZoneIds(
      _class.reference.pointer,
      _id_getAvailableZoneIds as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JString?>?>(
      const jni$_.JSetNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
    );
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;Ljava/util/Map;)Ljava/time/ZoneId;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId of(java.lang.String string, java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? of(
    jni$_.JString? string,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$map.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/time/ZoneId;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId of(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? of$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_ofOffset = _class.staticMethodId(
    r'ofOffset',
    r'(Ljava/lang/String;Ljava/time/ZoneOffset;)Ljava/time/ZoneId;',
  );

  static final _ofOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId ofOffset(java.lang.String string, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? ofOffset(jni$_.JString? string, ZoneOffset? zoneOffset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _ofOffset(
      _class.reference.pointer,
      _id_ofOffset as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$zoneOffset.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneId;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() {
    return _getId(
      reference.pointer,
      _id_getId as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle textStyle, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName(
    jni$_.JObject? textStyle,
    jni$_.JObject? locale,
  ) {
    final _$textStyle = textStyle?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
      _$textStyle.pointer,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/time/zone/ZoneRules;',
  );

  static final _getRules =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRules() {
    return _getRules(
      reference.pointer,
      _id_getRules as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_normalized = _class.instanceMethodId(
    r'normalized',
    r'()Ljava/time/ZoneId;',
  );

  static final _normalized =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneId normalized()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneId? normalized() {
    return _normalized(
      reference.pointer,
      _id_normalized as jni$_.JMethodIDPtr,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZoneId$NullableType extends jni$_.JObjType<ZoneId?> {
  @jni$_.internal
  const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZoneId.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneId$NullableType) &&
        other is $ZoneId$NullableType;
  }
}

final class $ZoneId$Type extends jni$_.JObjType<ZoneId> {
  @jni$_.internal
  const $ZoneId$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId fromReference(jni$_.JReference reference) =>
      ZoneId.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneId$Type) && other is $ZoneId$Type;
  }
}

/// from: `java.time.OffsetDateTime`
class OffsetDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OffsetDateTime> $type;

  @jni$_.internal
  OffsetDateTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/OffsetDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OffsetDateTime$NullableType();
  static const type = $OffsetDateTime$Type();
  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/OffsetDateTime;',
  );

  /// from: `static public final java.time.OffsetDateTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? get MIN =>
      _id_MIN.get(_class, const $OffsetDateTime$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/OffsetDateTime;',
  );

  /// from: `static public final java.time.OffsetDateTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? get MAX =>
      _id_MAX.get(_class, const $OffsetDateTime$NullableType());

  static final _id_timeLineOrder = _class.staticMethodId(
    r'timeLineOrder',
    r'()Ljava/util/Comparator;',
  );

  static final _timeLineOrder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Comparator<java.time.OffsetDateTime> timeLineOrder()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? timeLineOrder() {
    return _timeLineOrder(
      _class.reference.pointer,
      _id_timeLineOrder as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/OffsetDateTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.OffsetDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/OffsetDateTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/OffsetDateTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime of(java.time.LocalDate localDate, java.time.LocalTime localTime, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? of(
    LocalDate? localDate,
    LocalTime? localTime,
    ZoneOffset? zoneOffset,
  ) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localTime.pointer,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime of(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? of$1(
    LocalDateTime? localDateTime,
    ZoneOffset? zoneOffset,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(IIIIIIILjava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime of(int i, int i1, int i2, int i3, int i4, int i5, int i6, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? of$2(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    ZoneOffset? zoneOffset,
  ) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/OffsetDateTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/OffsetDateTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/OffsetDateTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/OffsetDateTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneOffset? getOffset() {
    return _getOffset(
      reference.pointer,
      _id_getOffset as jni$_.JMethodIDPtr,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_withOffsetSameLocal = _class.instanceMethodId(
    r'withOffsetSameLocal',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _withOffsetSameLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime withOffsetSameLocal(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withOffsetSameLocal(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameLocal(
      reference.pointer,
      _id_withOffsetSameLocal as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withOffsetSameInstant = _class.instanceMethodId(
    r'withOffsetSameInstant',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _withOffsetSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime withOffsetSameInstant(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withOffsetSameInstant(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameInstant(
      reference.pointer,
      _id_withOffsetSameInstant as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_toLocalDateTime = _class.instanceMethodId(
    r'toLocalDateTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _toLocalDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDateTime toLocalDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? toLocalDateTime() {
    return _toLocalDateTime(
      reference.pointer,
      _id_toLocalDateTime as jni$_.JMethodIDPtr,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? toLocalDate() {
    return _toLocalDate(
      reference.pointer,
      _id_toLocalDate as jni$_.JMethodIDPtr,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() {
    return _getYear(
      reference.pointer,
      _id_getYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() {
    return _getMonthValue(
      reference.pointer,
      _id_getMonthValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() {
    return _getMonth(
      reference.pointer,
      _id_getMonth as jni$_.JMethodIDPtr,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() {
    return _getDayOfMonth(
      reference.pointer,
      _id_getDayOfMonth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() {
    return _getDayOfYear(
      reference.pointer,
      _id_getDayOfYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() {
    return _getDayOfWeek(
      reference.pointer,
      _id_getDayOfWeek as jni$_.JMethodIDPtr,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() {
    return _toLocalTime(
      reference.pointer,
      _id_toLocalTime as jni$_.JMethodIDPtr,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() {
    return _getHour(
      reference.pointer,
      _id_getHour as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() {
    return _getMinute(
      reference.pointer,
      _id_getMinute as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() {
    return _getSecond(
      reference.pointer,
      _id_getSecond as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/OffsetDateTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/OffsetDateTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withYear(int i) {
    return _withYear(
      reference.pointer,
      _id_withYear as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withMonth(int i) {
    return _withMonth(
      reference.pointer,
      _id_withMonth as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withDayOfMonth(int i) {
    return _withDayOfMonth(
      reference.pointer,
      _id_withDayOfMonth as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withDayOfYear(int i) {
    return _withDayOfYear(
      reference.pointer,
      _id_withDayOfYear as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withHour(int i) {
    return _withHour(
      reference.pointer,
      _id_withHour as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withMinute(int i) {
    return _withMinute(
      reference.pointer,
      _id_withMinute as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withSecond(int i) {
    return _withSecond(
      reference.pointer,
      _id_withSecond as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withNano(int i) {
    return _withNano(
      reference.pointer,
      _id_withNano as jni$_.JMethodIDPtr,
      i,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/OffsetDateTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetDateTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetDateTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusYears(int j) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusMonths(int j) {
    return _plusMonths(
      reference.pointer,
      _id_plusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusWeeks(int j) {
    return _plusWeeks(
      reference.pointer,
      _id_plusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusDays(int j) {
    return _plusDays(
      reference.pointer,
      _id_plusDays as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusHours(int j) {
    return _plusHours(
      reference.pointer,
      _id_plusHours as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusMinutes(int j) {
    return _plusMinutes(
      reference.pointer,
      _id_plusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetDateTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetDateTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusYears(int j) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusMonths(int j) {
    return _minusMonths(
      reference.pointer,
      _id_minusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusWeeks(int j) {
    return _minusWeeks(
      reference.pointer,
      _id_minusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusDays(int j) {
    return _minusDays(
      reference.pointer,
      _id_minusDays as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusHours(int j) {
    return _minusHours(
      reference.pointer,
      _id_minusHours as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusMinutes(int j) {
    return _minusMinutes(
      reference.pointer,
      _id_minusMinutes as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atZoneSameInstant = _class.instanceMethodId(
    r'atZoneSameInstant',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZoneSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZoneSameInstant(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZoneSameInstant(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZoneSameInstant(
      reference.pointer,
      _id_atZoneSameInstant as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_atZoneSimilarLocal = _class.instanceMethodId(
    r'atZoneSimilarLocal',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZoneSimilarLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZoneSimilarLocal(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZoneSimilarLocal(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZoneSimilarLocal(
      reference.pointer,
      _id_atZoneSimilarLocal as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toOffsetTime = _class.instanceMethodId(
    r'toOffsetTime',
    r'()Ljava/time/OffsetTime;',
  );

  static final _toOffsetTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.OffsetTime toOffsetTime()`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? toOffsetTime() {
    return _toOffsetTime(
      reference.pointer,
      _id_toOffsetTime as jni$_.JMethodIDPtr,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_toZonedDateTime = _class.instanceMethodId(
    r'toZonedDateTime',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _toZonedDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime toZonedDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? toZonedDateTime() {
    return _toZonedDateTime(
      reference.pointer,
      _id_toZonedDateTime as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toInstant = _class.instanceMethodId(
    r'toInstant',
    r'()Ljava/time/Instant;',
  );

  static final _toInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Instant toInstant()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? toInstant() {
    return _toInstant(
      reference.pointer,
      _id_toInstant as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'()J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toEpochSecond()`
  int toEpochSecond() {
    return _toEpochSecond(
      reference.pointer,
      _id_toEpochSecond as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/OffsetDateTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.OffsetDateTime offsetDateTime)`
  int compareTo(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/OffsetDateTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.OffsetDateTime offsetDateTime)`
  bool isAfter(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/OffsetDateTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.OffsetDateTime offsetDateTime)`
  bool isBefore(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/OffsetDateTime;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.OffsetDateTime offsetDateTime)`
  bool isEqual(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(OffsetDateTime? offsetDateTime) {
    return compareTo(offsetDateTime) < 0;
  }

  bool operator <=(OffsetDateTime? offsetDateTime) {
    return compareTo(offsetDateTime) <= 0;
  }

  bool operator >(OffsetDateTime? offsetDateTime) {
    return compareTo(offsetDateTime) > 0;
  }

  bool operator >=(OffsetDateTime? offsetDateTime) {
    return compareTo(offsetDateTime) >= 0;
  }
}

final class $OffsetDateTime$NullableType
    extends jni$_.JObjType<OffsetDateTime?> {
  @jni$_.internal
  const $OffsetDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetDateTime;';

  @jni$_.internal
  @core$_.override
  OffsetDateTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OffsetDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OffsetDateTime$NullableType) &&
        other is $OffsetDateTime$NullableType;
  }
}

final class $OffsetDateTime$Type extends jni$_.JObjType<OffsetDateTime> {
  @jni$_.internal
  const $OffsetDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetDateTime;';

  @jni$_.internal
  @core$_.override
  OffsetDateTime fromReference(jni$_.JReference reference) =>
      OffsetDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetDateTime?> get nullableType =>
      const $OffsetDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OffsetDateTime$Type) &&
        other is $OffsetDateTime$Type;
  }
}

/// from: `java.time.Year`
class Year extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Year> $type;

  @jni$_.internal
  Year.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Year');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Year$NullableType();
  static const type = $Year$Type();

  /// from: `static public final int MIN_VALUE`
  static const MIN_VALUE = -999999999;

  /// from: `static public final int MAX_VALUE`
  static const MAX_VALUE = 999999999;
  static final _id_now = _class.staticMethodId(r'now', r'()Ljava/time/Year;');

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Year now()`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/Year;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/Year;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_of = _class.staticMethodId(r'of', r'(I)Ljava/time/Year;');

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Year of(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? of(int i) {
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Year;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Year;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/Year;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_isLeap = _class.staticMethodId(r'isLeap', r'(J)Z');

  static final _isLeap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public boolean isLeap(long j)`
  static bool isLeap(int j) {
    return _isLeap(
      _class.reference.pointer,
      _id_isLeap as jni$_.JMethodIDPtr,
      j,
    ).boolean;
  }

  static final _id_getValue = _class.instanceMethodId(r'getValue', r'()I');

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getValue()`
  int getValue() {
    return _getValue(
      reference.pointer,
      _id_getValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_isLeap$1 = _class.instanceMethodId(r'isLeap', r'()Z');

  static final _isLeap$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLeap()`
  bool isLeap$1() {
    return _isLeap$1(
      reference.pointer,
      _id_isLeap$1 as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isValidMonthDay = _class.instanceMethodId(
    r'isValidMonthDay',
    r'(Ljava/time/MonthDay;)Z',
  );

  static final _isValidMonthDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isValidMonthDay(java.time.MonthDay monthDay)`
  bool isValidMonthDay(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _isValidMonthDay(
      reference.pointer,
      _id_isValidMonthDay as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).boolean;
  }

  static final _id_length = _class.instanceMethodId(r'length', r'()I');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int length()`
  int length() {
    return _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Year;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Year;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.Year with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Year;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Year;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/Year;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Year plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? plusYears(int j) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      j,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Year;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Year;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/Year;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Year minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? minusYears(int j) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      j,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDay = _class.instanceMethodId(
    r'atDay',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _atDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate atDay(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atDay(int i) {
    return _atDay(
      reference.pointer,
      _id_atDay as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_atMonth = _class.instanceMethodId(
    r'atMonth',
    r'(Ljava/time/Month;)Ljava/time/YearMonth;',
  );

  static final _atMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth atMonth(java.time.Month month)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? atMonth(Month? month) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _atMonth(
      reference.pointer,
      _id_atMonth as jni$_.JMethodIDPtr,
      _$month.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_atMonth$1 = _class.instanceMethodId(
    r'atMonth',
    r'(I)Ljava/time/YearMonth;',
  );

  static final _atMonth$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth atMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? atMonth$1(int i) {
    return _atMonth$1(
      reference.pointer,
      _id_atMonth$1 as jni$_.JMethodIDPtr,
      i,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_atMonthDay = _class.instanceMethodId(
    r'atMonthDay',
    r'(Ljava/time/MonthDay;)Ljava/time/LocalDate;',
  );

  static final _atMonthDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate atMonthDay(java.time.MonthDay monthDay)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atMonthDay(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _atMonthDay(
      reference.pointer,
      _id_atMonthDay as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Year;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.Year year)`
  int compareTo(Year? year) {
    final _$year = year?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$year.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/Year;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.Year year)`
  bool isAfter(Year? year) {
    final _$year = year?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$year.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/Year;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.Year year)`
  bool isBefore(Year? year) {
    final _$year = year?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$year.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(Year? year) {
    return compareTo(year) < 0;
  }

  bool operator <=(Year? year) {
    return compareTo(year) <= 0;
  }

  bool operator >(Year? year) {
    return compareTo(year) > 0;
  }

  bool operator >=(Year? year) {
    return compareTo(year) >= 0;
  }
}

final class $Year$NullableType extends jni$_.JObjType<Year?> {
  @jni$_.internal
  const $Year$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Year;';

  @jni$_.internal
  @core$_.override
  Year? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Year.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Year?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Year$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Year$NullableType) &&
        other is $Year$NullableType;
  }
}

final class $Year$Type extends jni$_.JObjType<Year> {
  @jni$_.internal
  const $Year$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Year;';

  @jni$_.internal
  @core$_.override
  Year fromReference(jni$_.JReference reference) =>
      Year.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Year?> get nullableType => const $Year$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Year$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Year$Type) && other is $Year$Type;
  }
}

/// from: `java.time.DayOfWeek`
class DayOfWeek extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DayOfWeek> $type;

  @jni$_.internal
  DayOfWeek.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/DayOfWeek');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DayOfWeek$NullableType();
  static const type = $DayOfWeek$Type();
  static final _id_MONDAY = _class.staticFieldId(
    r'MONDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek MONDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get MONDAY =>
      _id_MONDAY.get(_class, const $DayOfWeek$Type());

  static final _id_TUESDAY = _class.staticFieldId(
    r'TUESDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek TUESDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get TUESDAY =>
      _id_TUESDAY.get(_class, const $DayOfWeek$Type());

  static final _id_WEDNESDAY = _class.staticFieldId(
    r'WEDNESDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek WEDNESDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get WEDNESDAY =>
      _id_WEDNESDAY.get(_class, const $DayOfWeek$Type());

  static final _id_THURSDAY = _class.staticFieldId(
    r'THURSDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek THURSDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get THURSDAY =>
      _id_THURSDAY.get(_class, const $DayOfWeek$Type());

  static final _id_FRIDAY = _class.staticFieldId(
    r'FRIDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek FRIDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get FRIDAY =>
      _id_FRIDAY.get(_class, const $DayOfWeek$Type());

  static final _id_SATURDAY = _class.staticFieldId(
    r'SATURDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek SATURDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get SATURDAY =>
      _id_SATURDAY.get(_class, const $DayOfWeek$Type());

  static final _id_SUNDAY = _class.staticFieldId(
    r'SUNDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek SUNDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get SUNDAY =>
      _id_SUNDAY.get(_class, const $DayOfWeek$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/time/DayOfWeek;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.DayOfWeek[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<DayOfWeek?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<DayOfWeek?>?>(
      const jni$_.JArrayNullableType<DayOfWeek?>($DayOfWeek$NullableType()),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/time/DayOfWeek;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.DayOfWeek valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(I)Ljava/time/DayOfWeek;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.DayOfWeek of(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek? of(int i) {
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/DayOfWeek;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.DayOfWeek from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_getValue = _class.instanceMethodId(r'getValue', r'()I');

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getValue()`
  int getValue() {
    return _getValue(
      reference.pointer,
      _id_getValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle textStyle, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName(
    jni$_.JObject? textStyle,
    jni$_.JObject? locale,
  ) {
    final _$textStyle = textStyle?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
      _$textStyle.pointer,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(J)Ljava/time/DayOfWeek;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.DayOfWeek plus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? plus(int j) {
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      j,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(J)Ljava/time/DayOfWeek;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.DayOfWeek minus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? minus(int j) {
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      j,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $DayOfWeek$NullableType extends jni$_.JObjType<DayOfWeek?> {
  @jni$_.internal
  const $DayOfWeek$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DayOfWeek;';

  @jni$_.internal
  @core$_.override
  DayOfWeek? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DayOfWeek.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DayOfWeek?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DayOfWeek$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DayOfWeek$NullableType) &&
        other is $DayOfWeek$NullableType;
  }
}

final class $DayOfWeek$Type extends jni$_.JObjType<DayOfWeek> {
  @jni$_.internal
  const $DayOfWeek$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DayOfWeek;';

  @jni$_.internal
  @core$_.override
  DayOfWeek fromReference(jni$_.JReference reference) =>
      DayOfWeek.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DayOfWeek?> get nullableType =>
      const $DayOfWeek$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DayOfWeek$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DayOfWeek$Type) && other is $DayOfWeek$Type;
  }
}

/// from: `java.time.LocalDate`
class LocalDate extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LocalDate> $type;

  @jni$_.internal
  LocalDate.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/LocalDate');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LocalDate$NullableType();
  static const type = $LocalDate$Type();
  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/LocalDate;');

  /// from: `static public final java.time.LocalDate MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? get MIN =>
      _id_MIN.get(_class, const $LocalDate$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/LocalDate;');

  /// from: `static public final java.time.LocalDate MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? get MAX =>
      _id_MAX.get(_class, const $LocalDate$NullableType());

  static final _id_EPOCH = _class.staticFieldId(
    r'EPOCH',
    r'Ljava/time/LocalDate;',
  );

  /// from: `static public final java.time.LocalDate EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? get EPOCH =>
      _id_EPOCH.get(_class, const $LocalDate$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/LocalDate;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.LocalDate now()`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/LocalDate;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/LocalDate;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;I)Ljava/time/LocalDate;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Pointer<jni$_.Void>, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate of(int i, java.time.Month month, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? of(int i, Month? month, int i1) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(III)Ljava/time/LocalDate;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate of(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? of$1(int i, int i1, int i2) {
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_ofYearDay = _class.staticMethodId(
    r'ofYearDay',
    r'(II)Ljava/time/LocalDate;',
  );

  static final _ofYearDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate ofYearDay(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? ofYearDay(int i, int i1) {
    return _ofYearDay(
      _class.reference.pointer,
      _id_ofYearDay as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/LocalDate;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_ofEpochDay = _class.staticMethodId(
    r'ofEpochDay',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _ofEpochDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate ofEpochDay(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? ofEpochDay(int j) {
    return _ofEpochDay(
      _class.reference.pointer,
      _id_ofEpochDay as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/LocalDate;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/LocalDate;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/LocalDate;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getChronology = _class.instanceMethodId(
    r'getChronology',
    r'()Ljava/time/chrono/IsoChronology;',
  );

  static final _getChronology =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.chrono.IsoChronology getChronology()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChronology() {
    return _getChronology(
      reference.pointer,
      _id_getChronology as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getEra = _class.instanceMethodId(
    r'getEra',
    r'()Ljava/time/chrono/IsoEra;',
  );

  static final _getEra =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.chrono.IsoEra getEra()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getEra() {
    return _getEra(
      reference.pointer,
      _id_getEra as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() {
    return _getYear(
      reference.pointer,
      _id_getYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() {
    return _getMonthValue(
      reference.pointer,
      _id_getMonthValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() {
    return _getMonth(
      reference.pointer,
      _id_getMonth as jni$_.JMethodIDPtr,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() {
    return _getDayOfMonth(
      reference.pointer,
      _id_getDayOfMonth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() {
    return _getDayOfYear(
      reference.pointer,
      _id_getDayOfYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() {
    return _getDayOfWeek(
      reference.pointer,
      _id_getDayOfWeek as jni$_.JMethodIDPtr,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_isLeapYear = _class.instanceMethodId(r'isLeapYear', r'()Z');

  static final _isLeapYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLeapYear()`
  bool isLeapYear() {
    return _isLeapYear(
      reference.pointer,
      _id_isLeapYear as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_lengthOfMonth = _class.instanceMethodId(
    r'lengthOfMonth',
    r'()I',
  );

  static final _lengthOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfMonth()`
  int lengthOfMonth() {
    return _lengthOfMonth(
      reference.pointer,
      _id_lengthOfMonth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_lengthOfYear = _class.instanceMethodId(
    r'lengthOfYear',
    r'()I',
  );

  static final _lengthOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfYear()`
  int lengthOfYear() {
    return _lengthOfYear(
      reference.pointer,
      _id_lengthOfYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/LocalDate;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/LocalDate;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.LocalDate with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withYear(int i) {
    return _withYear(
      reference.pointer,
      _id_withYear as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withMonth(int i) {
    return _withMonth(
      reference.pointer,
      _id_withMonth as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withDayOfMonth(int i) {
    return _withDayOfMonth(
      reference.pointer,
      _id_withDayOfMonth as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withDayOfYear(int i) {
    return _withDayOfYear(
      reference.pointer,
      _id_withDayOfYear as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDate;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDate;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusYears(int j) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusMonths(int j) {
    return _plusMonths(
      reference.pointer,
      _id_plusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusWeeks(int j) {
    return _plusWeeks(
      reference.pointer,
      _id_plusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusDays(int j) {
    return _plusDays(
      reference.pointer,
      _id_plusDays as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDate;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDate;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusYears(int j) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusMonths(int j) {
    return _minusMonths(
      reference.pointer,
      _id_minusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusWeeks(int j) {
    return _minusWeeks(
      reference.pointer,
      _id_minusWeeks as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusDays(int j) {
    return _minusDays(
      reference.pointer,
      _id_minusDays as jni$_.JMethodIDPtr,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_until$1 = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/chrono/ChronoLocalDate;)Ljava/time/Period;',
  );

  static final _until$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Period until(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? until$1(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _until$1(
      reference.pointer,
      _id_until$1 as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_datesUntil = _class.instanceMethodId(
    r'datesUntil',
    r'(Ljava/time/LocalDate;)Ljava/util/stream/Stream;',
  );

  static final _datesUntil =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.stream.Stream<java.time.LocalDate> datesUntil(java.time.LocalDate localDate)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? datesUntil(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _datesUntil(
      reference.pointer,
      _id_datesUntil as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_datesUntil$1 = _class.instanceMethodId(
    r'datesUntil',
    r'(Ljava/time/LocalDate;Ljava/time/Period;)Ljava/util/stream/Stream;',
  );

  static final _datesUntil$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.stream.Stream<java.time.LocalDate> datesUntil(java.time.LocalDate localDate, java.time.Period period)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? datesUntil$1(LocalDate? localDate, Period? period) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$period = period?.reference ?? jni$_.jNullReference;
    return _datesUntil$1(
      reference.pointer,
      _id_datesUntil$1 as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$period.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atTime = _class.instanceMethodId(
    r'atTime',
    r'(Ljava/time/LocalTime;)Ljava/time/LocalDateTime;',
  );

  static final _atTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(java.time.LocalTime localTime)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _atTime(
      reference.pointer,
      _id_atTime as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atTime$1 = _class.instanceMethodId(
    r'atTime',
    r'(II)Ljava/time/LocalDateTime;',
  );

  static final _atTime$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime$1(int i, int i1) {
    return _atTime$1(
      reference.pointer,
      _id_atTime$1 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atTime$2 = _class.instanceMethodId(
    r'atTime',
    r'(III)Ljava/time/LocalDateTime;',
  );

  static final _atTime$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime$2(int i, int i1, int i2) {
    return _atTime$2(
      reference.pointer,
      _id_atTime$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atTime$3 = _class.instanceMethodId(
    r'atTime',
    r'(IIII)Ljava/time/LocalDateTime;',
  );

  static final _atTime$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime$3(int i, int i1, int i2, int i3) {
    return _atTime$3(
      reference.pointer,
      _id_atTime$3 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atTime$4 = _class.instanceMethodId(
    r'atTime',
    r'(Ljava/time/OffsetTime;)Ljava/time/OffsetDateTime;',
  );

  static final _atTime$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atTime(java.time.OffsetTime offsetTime)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atTime$4(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _atTime$4(
      reference.pointer,
      _id_atTime$4 as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_atStartOfDay = _class.instanceMethodId(
    r'atStartOfDay',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _atStartOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDateTime atStartOfDay()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atStartOfDay() {
    return _atStartOfDay(
      reference.pointer,
      _id_atStartOfDay as jni$_.JMethodIDPtr,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atStartOfDay$1 = _class.instanceMethodId(
    r'atStartOfDay',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atStartOfDay$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atStartOfDay(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atStartOfDay$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atStartOfDay$1(
      reference.pointer,
      _id_atStartOfDay$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toEpochDay = _class.instanceMethodId(r'toEpochDay', r'()J');

  static final _toEpochDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toEpochDay()`
  int toEpochDay() {
    return _toEpochDay(
      reference.pointer,
      _id_toEpochDay as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'(Ljava/time/LocalTime;Ljava/time/ZoneOffset;)J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long toEpochSecond(java.time.LocalTime localTime, java.time.ZoneOffset zoneOffset)`
  int toEpochSecond(LocalTime? localTime, ZoneOffset? zoneOffset) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _toEpochSecond(
      reference.pointer,
      _id_toEpochSecond as jni$_.JMethodIDPtr,
      _$localTime.pointer,
      _$zoneOffset.pointer,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/chrono/ChronoLocalDate;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  int compareTo(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/chrono/ChronoLocalDate;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  bool isAfter(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/chrono/ChronoLocalDate;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  bool isBefore(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/chrono/ChronoLocalDate;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  bool isEqual(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $LocalDate$NullableType extends jni$_.JObjType<LocalDate?> {
  @jni$_.internal
  const $LocalDate$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDate;';

  @jni$_.internal
  @core$_.override
  LocalDate? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LocalDate.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDate?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDate$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LocalDate$NullableType) &&
        other is $LocalDate$NullableType;
  }
}

final class $LocalDate$Type extends jni$_.JObjType<LocalDate> {
  @jni$_.internal
  const $LocalDate$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDate;';

  @jni$_.internal
  @core$_.override
  LocalDate fromReference(jni$_.JReference reference) =>
      LocalDate.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDate?> get nullableType =>
      const $LocalDate$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDate$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LocalDate$Type) && other is $LocalDate$Type;
  }
}

/// from: `java.time.YearMonth`
class YearMonth extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<YearMonth> $type;

  @jni$_.internal
  YearMonth.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/YearMonth');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $YearMonth$NullableType();
  static const type = $YearMonth$Type();
  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/YearMonth;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.YearMonth now()`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/YearMonth;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/YearMonth;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;)Ljava/time/YearMonth;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth of(int i, java.time.Month month)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? of(int i, Month? month) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(II)Ljava/time/YearMonth;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.YearMonth of(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? of$1(int i, int i1) {
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/YearMonth;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/YearMonth;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/YearMonth;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() {
    return _getYear(
      reference.pointer,
      _id_getYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() {
    return _getMonthValue(
      reference.pointer,
      _id_getMonthValue as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() {
    return _getMonth(
      reference.pointer,
      _id_getMonth as jni$_.JMethodIDPtr,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_isLeapYear = _class.instanceMethodId(r'isLeapYear', r'()Z');

  static final _isLeapYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLeapYear()`
  bool isLeapYear() {
    return _isLeapYear(
      reference.pointer,
      _id_isLeapYear as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isValidDay = _class.instanceMethodId(r'isValidDay', r'(I)Z');

  static final _isValidDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isValidDay(int i)`
  bool isValidDay(int i) {
    return _isValidDay(
      reference.pointer,
      _id_isValidDay as jni$_.JMethodIDPtr,
      i,
    ).boolean;
  }

  static final _id_lengthOfMonth = _class.instanceMethodId(
    r'lengthOfMonth',
    r'()I',
  );

  static final _lengthOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfMonth()`
  int lengthOfMonth() {
    return _lengthOfMonth(
      reference.pointer,
      _id_lengthOfMonth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_lengthOfYear = _class.instanceMethodId(
    r'lengthOfYear',
    r'()I',
  );

  static final _lengthOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfYear()`
  int lengthOfYear() {
    return _lengthOfYear(
      reference.pointer,
      _id_lengthOfYear as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/YearMonth;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/YearMonth;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.YearMonth with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/YearMonth;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? withYear(int i) {
    return _withYear(
      reference.pointer,
      _id_withYear as jni$_.JMethodIDPtr,
      i,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/YearMonth;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? withMonth(int i) {
    return _withMonth(
      reference.pointer,
      _id_withMonth as jni$_.JMethodIDPtr,
      i,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/YearMonth;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/YearMonth;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plusYears(int j) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      j,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plusMonths(int j) {
    return _plusMonths(
      reference.pointer,
      _id_plusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/YearMonth;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/YearMonth;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minusYears(int j) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      j,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minusMonths(int j) {
    return _minusMonths(
      reference.pointer,
      _id_minusMonths as jni$_.JMethodIDPtr,
      j,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDay = _class.instanceMethodId(
    r'atDay',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _atDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate atDay(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atDay(int i) {
    return _atDay(
      reference.pointer,
      _id_atDay as jni$_.JMethodIDPtr,
      i,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_atEndOfMonth = _class.instanceMethodId(
    r'atEndOfMonth',
    r'()Ljava/time/LocalDate;',
  );

  static final _atEndOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate atEndOfMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atEndOfMonth() {
    return _atEndOfMonth(
      reference.pointer,
      _id_atEndOfMonth as jni$_.JMethodIDPtr,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/YearMonth;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.YearMonth yearMonth)`
  int compareTo(YearMonth? yearMonth) {
    final _$yearMonth = yearMonth?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$yearMonth.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/YearMonth;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.YearMonth yearMonth)`
  bool isAfter(YearMonth? yearMonth) {
    final _$yearMonth = yearMonth?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$yearMonth.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/YearMonth;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.YearMonth yearMonth)`
  bool isBefore(YearMonth? yearMonth) {
    final _$yearMonth = yearMonth?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$yearMonth.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(YearMonth? yearMonth) {
    return compareTo(yearMonth) < 0;
  }

  bool operator <=(YearMonth? yearMonth) {
    return compareTo(yearMonth) <= 0;
  }

  bool operator >(YearMonth? yearMonth) {
    return compareTo(yearMonth) > 0;
  }

  bool operator >=(YearMonth? yearMonth) {
    return compareTo(yearMonth) >= 0;
  }
}

final class $YearMonth$NullableType extends jni$_.JObjType<YearMonth?> {
  @jni$_.internal
  const $YearMonth$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/YearMonth;';

  @jni$_.internal
  @core$_.override
  YearMonth? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : YearMonth.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<YearMonth?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($YearMonth$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($YearMonth$NullableType) &&
        other is $YearMonth$NullableType;
  }
}

final class $YearMonth$Type extends jni$_.JObjType<YearMonth> {
  @jni$_.internal
  const $YearMonth$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/YearMonth;';

  @jni$_.internal
  @core$_.override
  YearMonth fromReference(jni$_.JReference reference) =>
      YearMonth.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<YearMonth?> get nullableType =>
      const $YearMonth$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($YearMonth$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($YearMonth$Type) && other is $YearMonth$Type;
  }
}

/// from: `java.time.Clock`
class Clock extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Clock> $type;

  @jni$_.internal
  Clock.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Clock');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Clock$NullableType();
  static const type = $Clock$Type();
  static final _id_systemUTC = _class.staticMethodId(
    r'systemUTC',
    r'()Ljava/time/Clock;',
  );

  static final _systemUTC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Clock systemUTC()`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? systemUTC() {
    return _systemUTC(
      _class.reference.pointer,
      _id_systemUTC as jni$_.JMethodIDPtr,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_systemDefaultZone = _class.staticMethodId(
    r'systemDefaultZone',
    r'()Ljava/time/Clock;',
  );

  static final _systemDefaultZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Clock systemDefaultZone()`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? systemDefaultZone() {
    return _systemDefaultZone(
      _class.reference.pointer,
      _id_systemDefaultZone as jni$_.JMethodIDPtr,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_system = _class.staticMethodId(
    r'system',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _system =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock system(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? system(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _system(
      _class.reference.pointer,
      _id_system as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tickMillis = _class.staticMethodId(
    r'tickMillis',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _tickMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tickMillis(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tickMillis(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _tickMillis(
      _class.reference.pointer,
      _id_tickMillis as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tickSeconds = _class.staticMethodId(
    r'tickSeconds',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _tickSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tickSeconds(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tickSeconds(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _tickSeconds(
      _class.reference.pointer,
      _id_tickSeconds as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tickMinutes = _class.staticMethodId(
    r'tickMinutes',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _tickMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tickMinutes(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tickMinutes(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _tickMinutes(
      _class.reference.pointer,
      _id_tickMinutes as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tick = _class.staticMethodId(
    r'tick',
    r'(Ljava/time/Clock;Ljava/time/Duration;)Ljava/time/Clock;',
  );

  static final _tick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tick(java.time.Clock clock, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tick(Clock? clock, Duration? duration) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _tick(
      _class.reference.pointer,
      _id_tick as jni$_.JMethodIDPtr,
      _$clock.pointer,
      _$duration.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_fixed = _class.staticMethodId(
    r'fixed',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _fixed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock fixed(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? fixed(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _fixed(
      _class.reference.pointer,
      _id_fixed as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_offset = _class.staticMethodId(
    r'offset',
    r'(Ljava/time/Clock;Ljava/time/Duration;)Ljava/time/Clock;',
  );

  static final _offset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock offset(java.time.Clock clock, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? offset(Clock? clock, Duration? duration) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _offset(
      _class.reference.pointer,
      _id_offset as jni$_.JMethodIDPtr,
      _$clock.pointer,
      _$duration.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_getZone = _class.instanceMethodId(
    r'getZone',
    r'()Ljava/time/ZoneId;',
  );

  static final _getZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneId? getZone() {
    return _getZone(
      reference.pointer,
      _id_getZone as jni$_.JMethodIDPtr,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_withZone = _class.instanceMethodId(
    r'withZone',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _withZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.time.Clock withZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  Clock? withZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZone(
      reference.pointer,
      _id_withZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_millis = _class.instanceMethodId(r'millis', r'()J');

  static final _millis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long millis()`
  int millis() {
    return _millis(reference.pointer, _id_millis as jni$_.JMethodIDPtr).long;
  }

  static final _id_instant = _class.instanceMethodId(
    r'instant',
    r'()Ljava/time/Instant;',
  );

  static final _instant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.Instant instant()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? instant() {
    return _instant(
      reference.pointer,
      _id_instant as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_system$1 = _class.staticMethodId(
    r'system',
    r'()Ljava/time/InstantSource;',
  );

  static final _system$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.InstantSource system()`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? system$1() {
    return _system$1(
      _class.reference.pointer,
      _id_system$1 as jni$_.JMethodIDPtr,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_tick$1 = _class.staticMethodId(
    r'tick',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _tick$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource tick(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? tick$1(
    InstantSource? instantSource,
    Duration? duration,
  ) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _tick$1(
      _class.reference.pointer,
      _id_tick$1 as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_fixed$1 = _class.staticMethodId(
    r'fixed',
    r'(Ljava/time/Instant;)Ljava/time/InstantSource;',
  );

  static final _fixed$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource fixed(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? fixed$1(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _fixed$1(
      _class.reference.pointer,
      _id_fixed$1 as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_offset$1 = _class.staticMethodId(
    r'offset',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _offset$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource offset(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? offset$1(
    InstantSource? instantSource,
    Duration? duration,
  ) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _offset$1(
      _class.reference.pointer,
      _id_offset$1 as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }
}

final class $Clock$NullableType extends jni$_.JObjType<Clock?> {
  @jni$_.internal
  const $Clock$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Clock;';

  @jni$_.internal
  @core$_.override
  Clock? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Clock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Clock?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Clock$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Clock$NullableType) &&
        other is $Clock$NullableType;
  }
}

final class $Clock$Type extends jni$_.JObjType<Clock> {
  @jni$_.internal
  const $Clock$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Clock;';

  @jni$_.internal
  @core$_.override
  Clock fromReference(jni$_.JReference reference) =>
      Clock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Clock?> get nullableType => const $Clock$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Clock$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Clock$Type) && other is $Clock$Type;
  }
}

/// from: `com.Accumulator`
class Accumulator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Accumulator> $type;

  @jni$_.internal
  Accumulator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Accumulator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Accumulator$NullableType();
  static const type = $Accumulator$Type();
  static final _id_accumulator = _class.instanceFieldId(r'accumulator', r'I');

  /// from: `public int accumulator`
  int get accumulator => _id_accumulator.get(this, const jni$_.jintType());

  /// from: `public int accumulator`
  set accumulator(int value) =>
      _id_accumulator.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator() {
    return Accumulator.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int initialValue)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator.new$1(int initialValue) {
    return Accumulator.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        initialValue,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Lcom/Accumulator;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(com.Accumulator other)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator.new$2(Accumulator? other) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    return Accumulator.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$other.pointer,
      ).reference,
    );
  }

  static final _id_add = _class.instanceMethodId(r'add', r'(I)V');

  static final _add =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void add(int value)`
  void add(int value) {
    _add(reference.pointer, _id_add as jni$_.JMethodIDPtr, value).check();
  }

  static final _id_add$1 = _class.instanceMethodId(r'add', r'(II)V');

  static final _add$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2)`
  void add$1(int value1, int value2) {
    _add$1(
      reference.pointer,
      _id_add$1 as jni$_.JMethodIDPtr,
      value1,
      value2,
    ).check();
  }

  static final _id_add$2 = _class.instanceMethodId(r'add', r'(III)V');

  static final _add$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2, int value3)`
  void add$2(int value1, int value2, int value3) {
    _add$2(
      reference.pointer,
      _id_add$2 as jni$_.JMethodIDPtr,
      value1,
      value2,
      value3,
    ).check();
  }

  static final _id_add$3 = _class.instanceMethodId(
    r'add',
    r'(Lcom/Accumulator;)V',
  );

  static final _add$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void add(com.Accumulator other)`
  void add$3(Accumulator? other) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    _add$3(
      reference.pointer,
      _id_add$3 as jni$_.JMethodIDPtr,
      _$other.pointer,
    ).check();
  }
}

final class $Accumulator$NullableType extends jni$_.JObjType<Accumulator?> {
  @jni$_.internal
  const $Accumulator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Accumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Accumulator$NullableType) &&
        other is $Accumulator$NullableType;
  }
}

final class $Accumulator$Type extends jni$_.JObjType<Accumulator> {
  @jni$_.internal
  const $Accumulator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator fromReference(jni$_.JReference reference) =>
      Accumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator?> get nullableType =>
      const $Accumulator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Accumulator$Type) &&
        other is $Accumulator$Type;
  }
}

/// from: `com.Accumulator$DoublingAccumulator`
class Accumulator$DoublingAccumulator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Accumulator$DoublingAccumulator> $type;

  @jni$_.internal
  Accumulator$DoublingAccumulator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'com/Accumulator$DoublingAccumulator',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Accumulator$DoublingAccumulator$NullableType();
  static const type = $Accumulator$DoublingAccumulator$Type();
  static final _id_accumulator = _class.instanceFieldId(r'accumulator', r'I');

  /// from: `public int accumulator`
  int get accumulator => _id_accumulator.get(this, const jni$_.jintType());

  /// from: `public int accumulator`
  set accumulator(int value) =>
      _id_accumulator.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'(Lcom/Accumulator;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(com.Accumulator $outerClass)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator$DoublingAccumulator(Accumulator $outerClass) {
    final _$$outerClass = $outerClass.reference;
    return Accumulator$DoublingAccumulator.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$$outerClass.pointer,
      ).reference,
    );
  }

  static final _id_add = _class.instanceMethodId(r'add', r'(I)V');

  static final _add =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void add(int value)`
  void add(int value) {
    _add(reference.pointer, _id_add as jni$_.JMethodIDPtr, value).check();
  }

  static final _id_add$1 = _class.instanceMethodId(r'add', r'(II)V');

  static final _add$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2)`
  void add$1(int value1, int value2) {
    _add$1(
      reference.pointer,
      _id_add$1 as jni$_.JMethodIDPtr,
      value1,
      value2,
    ).check();
  }

  static final _id_add$2 = _class.instanceMethodId(r'add', r'(III)V');

  static final _add$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2, int value3)`
  void add$2(int value1, int value2, int value3) {
    _add$2(
      reference.pointer,
      _id_add$2 as jni$_.JMethodIDPtr,
      value1,
      value2,
      value3,
    ).check();
  }
}

final class $Accumulator$DoublingAccumulator$NullableType
    extends jni$_.JObjType<Accumulator$DoublingAccumulator?> {
  @jni$_.internal
  const $Accumulator$DoublingAccumulator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator$DoublingAccumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator$DoublingAccumulator? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Accumulator$DoublingAccumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator$DoublingAccumulator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$DoublingAccumulator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Accumulator$DoublingAccumulator$NullableType) &&
        other is $Accumulator$DoublingAccumulator$NullableType;
  }
}

final class $Accumulator$DoublingAccumulator$Type
    extends jni$_.JObjType<Accumulator$DoublingAccumulator> {
  @jni$_.internal
  const $Accumulator$DoublingAccumulator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator$DoublingAccumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator$DoublingAccumulator fromReference(jni$_.JReference reference) =>
      Accumulator$DoublingAccumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator$DoublingAccumulator?> get nullableType =>
      const $Accumulator$DoublingAccumulator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$DoublingAccumulator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Accumulator$DoublingAccumulator$Type) &&
        other is $Accumulator$DoublingAccumulator$Type;
  }
}

/// from: `com.Example`
class Example extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example> $type;

  @jni$_.internal
  Example.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Example');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$NullableType();
  static const type = $Example$Type();
  static final _id_has$$dollar$$sign = _class.staticFieldId(
    r'has$dollar$sign',
    r'I',
  );

  /// from: `static public int has$dollar$sign`
  static int get has$$dollar$$sign =>
      _id_has$$dollar$$sign.get(_class, const jni$_.jintType());

  /// from: `static public int has$dollar$sign`
  static set has$$dollar$$sign(int value) =>
      _id_has$$dollar$$sign.set(_class, const jni$_.jintType(), value);

  static final _id_$_startsWithUnderscore = _class.staticFieldId(
    r'_startsWithUnderscore',
    r'I',
  );

  /// from: `static public int _startsWithUnderscore`
  static int get $_startsWithUnderscore =>
      _id_$_startsWithUnderscore.get(_class, const jni$_.jintType());

  /// from: `static public int _startsWithUnderscore`
  static set $_startsWithUnderscore(int value) =>
      _id_$_startsWithUnderscore.set(_class, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return Example.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_greet = _class.instanceMethodId(
    r'greet',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _greet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String greet(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? greet(jni$_.JString? name) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _greet(
      reference.pointer,
      _id_greet as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_enumValueToString = _class.instanceMethodId(
    r'enumValueToString',
    r'(Lcom/Example$Operation;)Ljava/lang/String;',
  );

  static final _enumValueToString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String enumValueToString(com.Example$Operation operation)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? enumValueToString(Example$Operation? operation) {
    final _$operation = operation?.reference ?? jni$_.jNullReference;
    return _enumValueToString(
      reference.pointer,
      _id_enumValueToString as jni$_.JMethodIDPtr,
      _$operation.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Example$NullableType extends jni$_.JObjType<Example?> {
  @jni$_.internal
  const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example;';

  @jni$_.internal
  @core$_.override
  Example? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Example.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$NullableType) &&
        other is $Example$NullableType;
  }
}

final class $Example$Type extends jni$_.JObjType<Example> {
  @jni$_.internal
  const $Example$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example;';

  @jni$_.internal
  @core$_.override
  Example fromReference(jni$_.JReference reference) =>
      Example.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Type) && other is $Example$Type;
  }
}

/// from: `com.Example$Operation`
class Example$Operation extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$Operation> $type;

  @jni$_.internal
  Example$Operation.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Example$Operation');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$Operation$NullableType();
  static const type = $Example$Operation$Type();
  static final _id_ADD = _class.staticFieldId(
    r'ADD',
    r'Lcom/Example$Operation;',
  );

  /// from: `static public final com.Example$Operation ADD`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation get ADD =>
      _id_ADD.get(_class, const $Example$Operation$Type());

  static final _id_SUBTRACT = _class.staticFieldId(
    r'SUBTRACT',
    r'Lcom/Example$Operation;',
  );

  /// from: `static public final com.Example$Operation SUBTRACT`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation get SUBTRACT =>
      _id_SUBTRACT.get(_class, const $Example$Operation$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/Example$Operation;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public com.Example$Operation[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Example$Operation?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Example$Operation?>?>(
      const jni$_.JArrayNullableType<Example$Operation?>(
        $Example$Operation$NullableType(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/Example$Operation;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public com.Example$Operation valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation? valueOf(jni$_.JString? name) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<Example$Operation?>(const $Example$Operation$NullableType());
  }
}

final class $Example$Operation$NullableType
    extends jni$_.JObjType<Example$Operation?> {
  @jni$_.internal
  const $Example$Operation$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example$Operation;';

  @jni$_.internal
  @core$_.override
  Example$Operation? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Example$Operation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Operation?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Operation$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Operation$NullableType) &&
        other is $Example$Operation$NullableType;
  }
}

final class $Example$Operation$Type extends jni$_.JObjType<Example$Operation> {
  @jni$_.internal
  const $Example$Operation$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example$Operation;';

  @jni$_.internal
  @core$_.override
  Example$Operation fromReference(jni$_.JReference reference) =>
      Example$Operation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Operation?> get nullableType =>
      const $Example$Operation$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Operation$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Operation$Type) &&
        other is $Example$Operation$Type;
  }
}

/// from: `com.Runnable`
class Runnable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Runnable> $type;

  @jni$_.internal
  Runnable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Runnable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Runnable$NullableType();
  static const type = $Runnable$Type();
  static final _id_run = _class.instanceMethodId(r'run', r'()I');

  static final _run =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int run()`
  int run() {
    return _run(reference.pointer, _id_run as jni$_.JMethodIDPtr).integer;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Runnable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()I') {
        final $r = _$impls[$p]!.run();
        return jni$_.JInteger($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Runnable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'com.Runnable', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Runnable.implement($Runnable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Runnable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Runnable {
  factory $Runnable({required int Function() run}) = _$Runnable;

  int run();
}

final class _$Runnable with $Runnable {
  _$Runnable({required int Function() run}) : _run = run;

  final int Function() _run;

  int run() {
    return _run();
  }
}

final class $Runnable$NullableType extends jni$_.JObjType<Runnable?> {
  @jni$_.internal
  const $Runnable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Runnable;';

  @jni$_.internal
  @core$_.override
  Runnable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Runnable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Runnable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Runnable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Runnable$NullableType) &&
        other is $Runnable$NullableType;
  }
}

final class $Runnable$Type extends jni$_.JObjType<Runnable> {
  @jni$_.internal
  const $Runnable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Runnable;';

  @jni$_.internal
  @core$_.override
  Runnable fromReference(jni$_.JReference reference) =>
      Runnable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Runnable?> get nullableType => const $Runnable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Runnable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Runnable$Type) && other is $Runnable$Type;
  }
}
